{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "stream-messages",
  "type": "registry:block",
  "description": "Stream team's chat messages for rendering in a chat window",
  "dependencies": [
    "@sitecore/stream-ui-core",
    "@mdi/js",
    "react-dropzone",
    "jotai",
    "sonner",
    "lodash",
    "react-textarea-autosize",
    "ai@4.1.20"
  ],
  "registryDependencies": [
    "button",
    "popover",
    "input",
    "separator",
    "avatar",
    "tooltip",
    "popover",
    "card",
    "select",
    "dialog"
  ],
  "files": [
    {
      "path": "registry/new-york/stream/blocks/chat/stream-messages.tsx",
      "content": "\"use client\"\n\nimport React, {\n  createContext,\n  useCallback,\n  useEffect,\n  useMemo,\n  type JSX,\n} from \"react\"\nimport { type UIMessage } from \"@ai-sdk/ui-utils\"\nimport { useChat, type UseChatHelpers } from \"ai/react\"\nimport {\n  Provider as JotaiProvider,\n  useAtom,\n  useAtomValue,\n  useSetAtom,\n} from \"jotai\"\nimport { toast } from \"sonner\"\n\nimport { useChatProvider } from \"./hooks/useChatProvider\"\nimport { Messages } from \"./Messages\"\nimport {\n  apiQueueAtom,\n  artifactsAtom,\n  brandkitIdAtom,\n  chatIdAtom,\n  configAtom,\n  hasErrorAtom,\n  isChatActionPendingAtom,\n  isLoadingAtom,\n  isNewChatAtom,\n  messagesIdsAtom,\n  postChatGenerateBodyAtom,\n  selectedChatWithIdAtom,\n} from \"./store/atoms\"\nimport { TOOL_ACTIONS, useToolDispatch } from \"./store/tools\"\nimport { type Session } from \"./store/types\"\nimport {\n  type MessageAnnotation,\n  type ResetSelections,\n  type SelectionValues,\n} from \"./types\"\nimport { useStreamMessagesClientsConfig } from \"./utils\"\n\nimport \"../../stream.css\"\n\nimport {\n  chat as chatApi,\n  dbMessagesToAIMessages,\n  HTTPError,\n  type ListUserChatMessagesModelResponseV2,\n} from \"@sitecore/stream-ui-core\"\nimport { type Message } from \"ai\"\nimport { last } from \"lodash\"\n\nimport { useGetChatMessages } from \"../../hooks/use-get-chat-messages\"\nimport { type Artifacts } from \"./store/types\"\n\nexport type ChatContextType = {\n  session: Session\n}\n\nexport type VercelAiUiProviderType = UseChatHelpers & {\n  brandkitId: string\n  chatId: string\n  addToolResult: ({\n    toolCallId,\n    result,\n  }: {\n    toolCallId: string\n    result: unknown\n  }) => void\n  rollbackChatChanges: (callbacks?: {\n    onRemoveChat?: () => void\n    onDeleteMessage?: () => void\n  }) => void\n  reset: (selections: ResetSelections) => void\n}\n\nexport const ChatContext = createContext<ChatContextType | undefined>(undefined)\nexport const VercelAiUiContext = createContext<\n  VercelAiUiProviderType | undefined\n>(undefined)\n\nconst baseUrlEnv = {\n  dev: \"-dev.sitecore-staging.cloud\",\n  qa: \"-qa.sitecore-staging.cloud\",\n  staging: \"-staging.sitecore-staging.cloud\",\n  preprod: \"-preprod.sitecorecloud.io\",\n  prod: \"sitecorecloud.io\",\n}\n\n/**\n * Configuration for example prompts displayed in the chat interface.\n */\ntype ExamplePrompt = {\n  /**\n   * Icon element to display alongside the prompt.\n   * @example <span className=\"text-md neutral-fg ml-auto\">ðŸ’¡</span>\n   */\n  icon: JSX.Element\n\n  /**\n   * The text content of the example prompt.\n   * @example \"Generate a creative brief for a new product launch\"\n   */\n  content: string\n}\n\nexport interface ChatProps {\n  session: Omit<Session, \"apiEnv\">\n  children?: React.ReactNode\n}\n\n/**\n * Props for the StreamMessages component.\n */\nexport interface StreamMessagesProps {\n  brandkitId: string\n  chatId: string\n  isNewChat: boolean\n  onStream?: (data: {\n    isStreaming: boolean\n    finished: boolean\n    message: Message | null\n  }) => void\n  /**\n   * Initial prompt to display in the chat interface.\n   * @example \"Generate a creative brief for a new product launch\"\n   * @default undefined\n   */\n  prompt?: string\n\n  /**\n   * Configuration options for customizing the chat interface.\n   * @default undefined\n   */\n  config?: {\n    /**\n     * Disclaimer text or component to display in the chat interface.\n     * @example \"This is a test disclaimer. It can be a string or a React node.\"\n     * @example <div className=\"text-sm text-neutral-500\"><p>AI responses may contain errors.</p></div>\n     * @default undefined\n     */\n    disclaimer?: string | React.ReactNode\n\n    /**\n     * Array of example prompts to show users before they start chatting.\n     * @example [\n     *   {\n     *     icon: <span className=\"text-md neutral-fg ml-auto\">ðŸ’¡</span>,\n     *     content: 'Generate a creative brief for a new product launch'\n     *   },\n     *   {\n     *     icon: <span className=\"text-md neutral-fg ml-auto\">ðŸ§ </span>,\n     *     content: 'Brainstorm some ideas for a social media campaign'\n     *   }\n     * ]\n     * @default undefined\n     */\n    examplePrompts?: ExamplePrompt[]\n  }\n}\n\nexport function Chat({ session, children }: ChatProps) {\n  const apiEnv = `${session.region}${baseUrlEnv[session.env]}`\n\n  return (\n    <ChatContext.Provider value={{ session: { ...session, apiEnv } }}>\n      <JotaiProvider>{children}</JotaiProvider>\n    </ChatContext.Provider>\n  )\n}\n\n/**\n * StreamMessages is a React component that provides a chat interface with AI capabilities.\n * It handles real-time messaging, tool invocations, and integrates with various AI services\n * for brainstorming, content generation, and more.\n *\n * @param props - The props for the StreamMessages component\n * @returns A JSX element rendering the complete chat interface\n *\n * @example\n * ```tsx\n * // Basic usage with required session configuration\n * <StreamMessages\n *   session={{\n *     brandkitId: '2f669d68-d5ab-4664-944a-b1504a1a2a6c',\n *     userId: 'auth0|1234567890',\n *     orgId: 'org_b07iKFjB2zYhi49p',\n *     chatId: 'e092c859-fce8-49be-b916-bf84477659d8',\n *     region: 'euw',\n *     env: 'dev',\n *     token: 'your-auth-token-here'\n *   }}\n * />\n *\n * // Advanced usage with custom configuration and example prompts\n * <StreamMessages\n *   session={{\n *     brandkitId: '2f669d68-d5ab-4664-944a-b1504a1a2a6c',\n *     userId: 'auth0|1234567890',\n *     orgId: 'org_b07iKFjB2zYhi49p',\n *     chatId: 'e092c859-fce8-49be-b916-bf84477659d8',\n *     region: 'euw',\n *     env: 'dev',\n *     token: 'your-auth-token-here'\n *   }}\n *   prompt=\"Generate a creative brief for a new product launch\"\n *   config={{\n *     examplePrompts: [\n *       {\n *         icon: <span className=\"text-md neutral-fg ml-auto\">ðŸ’¡</span>,\n *         content: 'Generate a creative brief for a new product launch',\n *       },\n *       {\n *         icon: <span className=\"text-md neutral-fg ml-auto\">ðŸ§ </span>,\n *         content: 'Brainstorm some ideas for a social media campaign',\n *       },\n *     ],\n *     disclaimer: (\n *       <div className=\"text-sm text-neutral-500\">\n *         <p>This is a test disclaimer. It can be a string or a React node.</p>\n *       </div>\n *     ),\n *   }}\n * />\n * ```\n *\n * @remarks\n * This component requires the stream clients to be loaded via `useStreamMessagesClientsConfig`\n * before it can function properly. It manages chat state through Jotai atoms and integrates\n * with the Vercel AI SDK for chat functionality.\n */\nfunction StreamMessages({\n  brandkitId,\n  chatId,\n  prompt,\n  config,\n  isNewChat,\n  onStream,\n}: StreamMessagesProps): JSX.Element {\n  /* Atoms */\n  const chatBodyAtom = useAtomValue(postChatGenerateBodyAtom)\n  const setMessageIds = useSetAtom(messagesIdsAtom)\n  const [isLoading, setIsLoading] = useAtom(isLoadingAtom)\n  const [, dispatchToolAction] = useToolDispatch()\n  const setConfig = useSetAtom(configAtom)\n\n  /* Hooks */\n  const { session } = useChatProvider()\n  const getChatMessages = useGetChatMessages(session.orgId, session.userId)\n  const setApiQueue = useSetAtom(apiQueueAtom)\n  const setArtifacts = useSetAtom(artifactsAtom)\n  const setSelectedChatWithId = useSetAtom(selectedChatWithIdAtom)\n  const setIsChatActionPending = useSetAtom(isChatActionPendingAtom)\n  const setHasError = useSetAtom(hasErrorAtom)\n  const [_isNewChat, setIsNewChat] = useAtom(isNewChatAtom)\n  const [_chatId, setChatId] = useAtom(chatIdAtom)\n  const setBrandkitId = useSetAtom(brandkitIdAtom)\n\n  const {\n    isLoading: _isLoading,\n    messages,\n    setMessages,\n    setInput,\n    stop,\n    ...chat\n  } = useChat({\n    api: `https://ai-chat-api-${session.region}${baseUrlEnv[session.env]}/api/chats/v1/organizations/${session.orgId}/users/${session.userId}/chats/${_chatId}/generatemessage`,\n    body: chatBodyAtom,\n    initialInput: prompt ?? \"\",\n    headers: {\n      Authorization: `Bearer ${session.token}`,\n      \"Content-Type\": \"application/json\",\n    },\n    experimental_throttle: 200,\n    onResponse: () => {\n      onStream?.({ isStreaming: true, finished: false, message: null })\n    },\n    onFinish: async (message) => {\n      const messageId = (\n        message?.annotations?.[0] as unknown as MessageAnnotation\n      )?.id\n      setMessageIds((prev) => [...prev, messageId])\n\n      onStream?.({ isStreaming: false, finished: true, message: message })\n    },\n    onError: (error) => {\n      console.error(\"Error:\", error)\n      onStream?.({ isStreaming: false, finished: true, message: null })\n    },\n  })\n\n  /* Computed */\n  const areMessagesAvailable = !!messages?.length\n\n  const reset = useCallback(\n    (selections: ResetSelections) => {\n      const actions = {\n        messages: (value?: Message[]) => {\n          setMessages(value ?? [])\n          setMessageIds([])\n          setSelectedChatWithId(\"\")\n        },\n        artifacts: (value?: Artifacts) => setArtifacts(value ?? {}),\n        isChatActionPending: (value?: boolean) =>\n          setIsChatActionPending(value ?? false),\n        hasError: (value?: boolean) => setHasError(value ?? false),\n        input: (value?: string) => setInput(value ?? \"\"),\n      }\n\n      selections.forEach((selection) => {\n        if (Array.isArray(selection)) {\n          const [key, value] = selection as SelectionValues\n          actions[key](value as never)\n        } else actions[selection]()\n      })\n    },\n    [\n      setArtifacts,\n      setHasError,\n      setInput,\n      setIsChatActionPending,\n      setMessageIds,\n      setMessages,\n      setSelectedChatWithId,\n    ]\n  )\n\n  const initMessages = useCallback(async (): Promise<void> => {\n    /* Get messages for a specific chat */\n    const messages: ListUserChatMessagesModelResponseV2[] =\n      await getChatMessages(_chatId)\n    const dbMessages = dbMessagesToAIMessages(messages) as UIMessage[]\n\n    setMessages(dbMessages)\n    setMessageIds(\n      dbMessages.map((message) => {\n        return (message?.annotations?.[0] as unknown as MessageAnnotation)?.id\n      })\n    )\n  }, [getChatMessages, _chatId, setMessageIds, setMessages])\n\n  const rollbackChatChanges = useCallback(\n    async (callbacks?: {\n      onRemoveChat?: () => void\n      onDeleteMessage?: () => void\n    }) => {\n      const { onRemoveChat, onDeleteMessage } = callbacks ?? {}\n\n      const messageAssistant = (last(messages) as Message)?.role === \"assistant\"\n      const messageId = (\n        (last(messages) as Message)\n          ?.annotations?.[0] as unknown as MessageAnnotation\n      )?.id\n\n      const isMessageAssistantInvalid = !messageAssistant || !messageId\n      const isFirstMessage = messages.length && messages.length <= 2\n\n      stop()\n      onStream?.({ isStreaming: false, finished: true, message: null })\n\n      queueMicrotask(() => {\n        setApiQueue({})\n        reset([\"hasError\", \"artifacts\"])\n      })\n\n      /* If there are two or fewer messages, then delete the chat */\n      if (isFirstMessage) {\n        try {\n          await chatApi.deleteUserChatApiChatsV1OrganizationsOrganizationIdUsersUserIdChatsChatIdDelete(\n            {\n              path: {\n                userId: session.userId,\n                chatId: _chatId,\n                organizationId: session.orgId,\n              },\n            }\n          )\n          await initMessages()\n\n          if (onRemoveChat) {\n            onRemoveChat()\n            return\n          }\n        } catch (error: unknown) {\n          const { response } = error as HTTPError\n          const { detail } = (await response.json()) as {\n            type: string\n            detail: string\n          }\n          toast.error(detail)\n        } finally {\n          queueMicrotask(() => {\n            setChatId(\"\")\n            setApiQueue({})\n            reset([\n              \"hasError\",\n              \"artifacts\",\n              \"isChatActionPending\",\n              \"input\",\n              \"messages\",\n              \"artifacts\",\n            ])\n          })\n        }\n        return\n      }\n\n      if (isMessageAssistantInvalid) {\n        if (onDeleteMessage) {\n          onDeleteMessage()\n          return\n        }\n        await initMessages()\n        return\n      }\n\n      try {\n        await chatApi.deleteUserChatMessageApiChatsV1OrganizationsOrganizationIdUsersUserIdChatsChatIdMessagesMessageIdDelete(\n          {\n            path: {\n              userId: session.userId,\n              chatId: _chatId,\n              organizationId: session.orgId,\n              messageId,\n            },\n          }\n        )\n        if (onDeleteMessage) {\n          onDeleteMessage()\n          return\n        }\n      } catch (error: unknown) {\n        const { response } = error as HTTPError\n        const { detail } = (await response.json()) as {\n          type: string\n          detail: string\n        }\n        toast.error(detail)\n      }\n    },\n    [\n      messages,\n      stop,\n      setChatId,\n      setApiQueue,\n      reset,\n      session.userId,\n      session.orgId,\n      _chatId,\n      initMessages,\n    ]\n  )\n\n  const handleNewChat = useCallback(() => {\n    setIsNewChat(false)\n    dispatchToolAction({ type: TOOL_ACTIONS.RESET_ALL_TOOLS })\n    setArtifacts({})\n    setMessages([])\n    setChatId(\"\")\n\n    if (isLoading) {\n      rollbackChatChanges({\n        onDeleteMessage: () => {\n          setMessages([])\n        },\n      })\n    }\n  }, [\n    dispatchToolAction,\n    isLoading,\n    rollbackChatChanges,\n    setArtifacts,\n    setChatId,\n    setIsNewChat,\n    setMessages,\n  ])\n\n  const updateInternalState = useCallback(() => {\n    if (chatId) setChatId(chatId)\n    if (brandkitId) setBrandkitId(brandkitId)\n    if (isNewChat) {\n      setIsNewChat(isNewChat)\n      handleNewChat()\n    }\n    if (config) setConfig(config)\n    if (_isLoading !== isLoading) {\n      setIsLoading(_isLoading)\n    }\n  }, [\n    _isLoading,\n    brandkitId,\n    chatId,\n    config,\n    handleNewChat,\n    isLoading,\n    isNewChat,\n    setBrandkitId,\n    setChatId,\n    setConfig,\n    setIsLoading,\n    setIsNewChat,\n  ])\n\n  const handleChatInit = useCallback(() => {\n    if (!_chatId) return\n\n    if (_isNewChat) {\n      setIsNewChat(false)\n      chat.handleSubmit()\n      return\n    }\n\n    if (!areMessagesAvailable) {\n      initMessages()\n    }\n  }, [\n    _chatId,\n    _isNewChat,\n    areMessagesAvailable,\n    chat,\n    initMessages,\n    setIsNewChat,\n  ])\n\n  useEffect(() => {\n    updateInternalState()\n    handleChatInit()\n  }, [handleChatInit, updateInternalState])\n\n  const context = useMemo(\n    () => ({\n      ...chat,\n      setInput,\n      reset,\n      rollbackChatChanges,\n      setMessages,\n      messages,\n      isLoading,\n      stop,\n      brandkitId,\n      chatId,\n    }),\n    [\n      brandkitId,\n      chat,\n      chatId,\n      isLoading,\n      messages,\n      reset,\n      rollbackChatChanges,\n      setInput,\n      setMessages,\n      stop,\n    ]\n  )\n\n  return (\n    <VercelAiUiContext.Provider value={context}>\n      <Messages />\n    </VercelAiUiContext.Provider>\n  )\n}\n\nexport { StreamMessages, useStreamMessagesClientsConfig }\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/stream-messages.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/Anchors.tsx",
      "content": "import React, { Fragment } from \"react\"\nimport { mdiLinkVariant, mdiOpenInNew } from \"@mdi/js\"\n\nimport { Button } from \"@/registry/new-york/ui/button\"\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/registry/new-york/ui/popover\"\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger,\n} from \"@/registry/new-york/ui/tooltip\"\n\nimport { cn } from \"../../lib/utils\"\nimport { StreamIcon } from \"../../ui/stream-icon\"\nimport { GetDocumentProxyUrl } from \"./GetDocumentProxyUrl\"\nimport type { Source } from \"./types\"\n\nexport interface AnchorsProps {\n  testId?: string\n  items: Source[]\n  className?: string\n  buttonClassName?: string\n}\n\nconst MAX_TAGS = 3\n\nexport function Anchors({\n  testId = \"anchors\",\n  items,\n  className,\n  buttonClassName,\n}: AnchorsProps): React.ReactNode {\n  if (!items?.length) return null\n\n  const button = ({\n    index,\n    name,\n    title,\n    url,\n  }: Source & { index: number | string }) => {\n    return (\n      <Tooltip>\n        <TooltipTrigger asChild>\n          <Button\n            data-testid={`${testId}_anchor_button_${index}`}\n            variant=\"outline\"\n            className={cn(\n              \"text-md text-blackAlpha-600 my-[6px] h-[33px] max-w-[146px] p-0 font-semibold\",\n              buttonClassName\n            )}\n          >\n            <GetDocumentProxyUrl\n              url={url}\n              item={(url) => {\n                return (\n                  <a\n                    href={url}\n                    className=\"flex h-full w-full items-center justify-center space-x-2 px-3\"\n                    target=\"_blank\"\n                    rel=\"noreferrer noopener\"\n                  >\n                    <StreamIcon path={mdiLinkVariant} />\n                    <span className=\"truncate\">{name || title}</span>\n                    <StreamIcon path={mdiOpenInNew} />\n                  </a>\n                )\n              }}\n            />\n          </Button>\n        </TooltipTrigger>\n        <TooltipContent>{name || title}</TooltipContent>\n      </Tooltip>\n    )\n  }\n\n  return (\n    <div\n      data-testid={`anchors_container`}\n      className={cn(\"my-[6px] flex flex-wrap items-center gap-x-3\", className)}\n    >\n      {items\n        ?.filter((_, index) => index < MAX_TAGS)\n        .map((item, index) => (\n          <Fragment key={`max_${index}`}>{button({ ...item, index })}</Fragment>\n        ))}\n      {items?.length > MAX_TAGS && (\n        <Popover>\n          <PopoverTrigger asChild>\n            <Button\n              variant=\"outline\"\n              className=\"text-md text-blackAlpha-600 h-[33px] px-3 py-0 font-semibold\"\n            >\n              +{items?.length - MAX_TAGS}\n            </Button>\n          </PopoverTrigger>\n          <PopoverContent className=\"flex w-min flex-col gap-4 p-4\" align=\"end\">\n            {items\n              ?.filter((_, index) => index > MAX_TAGS - 1)\n              .map((item, index) => (\n                <Fragment key={`rest_${index}`}>\n                  {button({ ...item, index: `additional_${index}` })}\n                </Fragment>\n              ))}\n          </PopoverContent>\n        </Popover>\n      )}\n    </div>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/Anchors.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/Icon.tsx",
      "content": "import React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nexport interface IconProps\n  extends React.SVGAttributes<SVGSVGElement>,\n    VariantProps<typeof iconVariants> {\n  path: string\n  aiGradient?:\n    | \"50\"\n    | \"100\"\n    | \"200\"\n    | \"300\"\n    | \"400\"\n    | \"500\"\n    | \"600\"\n    | \"700\"\n    | \"800\"\n    | \"900\"\n}\n\nconst iconVariants = cva(\"inline-block align-middle flex-shrink-0 leading-4\", {\n  variants: {\n    size: {\n      default: \"stream-w-icon stream-h-icon\",\n      \"3xs\": \"stream-w-icon-3xs stream-h-icon-3xs\",\n      \"2xs\": \"stream-w-icon-2xs stream-h-icon-2xs\",\n      xs: \"stream-w-icon-xs stream-h-icon-xs\",\n      sm: \"stream-w-icon-sm stream-h-icon-sm\",\n      md: \"stream-w-icon-md stream-h-icon-md\",\n      lg: \"stream-w-icon-lg stream-h-icon-lg\",\n      xl: \"stream-w-icon-xl stream-h-icon-xl\",\n      \"2xl\": \"stream-w-icon-2xl stream-h-icon-2xl\",\n      \"3xl\": \"stream-w-icon-3xl stream-h-icon-3xl\",\n      \"4xl\": \"stream-w-icon-4xl stream-h-icon-4xl\",\n      \"5xl\": \"stream-w-icon-5xl stream-h-icon-5xl\",\n      \"6xl\": \"stream-w-icon-6xl stream-h-icon-6xl\",\n      \"7xl\": \"stream-w-icon-7xl stream-h-icon-7xl\",\n      \"8xl\": \"stream-w-icon-8xl stream-h-icon-7xl\",\n    },\n  },\n  defaultVariants: {\n    size: \"default\",\n  },\n})\n\nexport function Icon({\n  path,\n  size,\n  className,\n  aiGradient,\n  ...rest\n}: IconProps): React.ReactNode {\n  return (\n    <svg\n      fill=\"currentColor\"\n      viewBox=\"0 0 24 24\"\n      {...rest}\n      className={iconVariants({ size, className })}\n    >\n      {aiGradient && (\n        <defs>\n          <linearGradient id=\"ai-gradient\" y1=\"100%\" y2=\"0\">\n            <stop stopColor={`var(--purple-${aiGradient})`} offset=\"0%\" />\n            <stop stopColor={`var(--red-${aiGradient})`} offset=\"100%\" />\n          </linearGradient>\n        </defs>\n      )}\n      <path fill={aiGradient ? \"url(#ai-gradient)\" : \"currentColor\"} d={path} />\n    </svg>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/Icon.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/LightBox.tsx",
      "content": "import React, {\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n  type SyntheticEvent,\n} from \"react\"\nimport {\n  mdiChevronLeft,\n  mdiChevronRight,\n  mdiClose,\n  mdiOpenInNew,\n} from \"@mdi/js\"\nimport { createPortal } from \"react-dom\"\n\nimport { Button } from \"@/registry/new-york/ui/button\"\n\nimport { cn } from \"../../lib/utils\"\nimport { StreamIcon } from \"../../ui/stream-icon\"\nimport { GetDocumentProxyUrl } from \"./GetDocumentProxyUrl\"\nimport type { Source } from \"./types\"\n\nexport interface LightBoxProps {\n  images: Source[]\n  imagesContainerClassName?: string\n  imageContainerClassName?: string\n  imageClassName?: string\n}\n\nconst MAX_PHOTOS = 3\n\nexport function LightBox({\n  images,\n  imagesContainerClassName,\n  imageContainerClassName,\n  imageClassName,\n}: LightBoxProps): React.ReactNode {\n  /* Hooks */\n  const [imageIndex, setImageIndex] = useState(0)\n  const [showLightBox, setShowLightBox] = useState(false)\n  const clickOutsideRef = useRef<HTMLDivElement | null>(null)\n\n  /* Computed */\n  const imagesLength = images?.length\n  const selectedImage = images[imageIndex]\n  const body = document.querySelector(\"body\") ?? ({} as HTMLBodyElement)\n\n  const handleOpenLightBoxOnClick = (imageIndex: number): void => {\n    setShowLightBox(true)\n    setImageIndex(imageIndex)\n  }\n\n  /* Events */\n  const handleCloseOnClick = useCallback(\n    (e: SyntheticEvent<HTMLButtonElement | HTMLDivElement>) => {\n      e.preventDefault()\n      e.stopPropagation()\n      setShowLightBox(false)\n    },\n    []\n  )\n\n  const handleImageControlsOnClick = (type: \"prev\" | \"next\"): void => {\n    switch (type) {\n      case \"prev\":\n        setImageIndex((prev) => (prev === 0 ? 0 : prev - 1))\n        break\n      case \"next\":\n        setImageIndex((prev) => (prev === imagesLength - 1 ? prev : prev + 1))\n        break\n    }\n  }\n\n  useEffect(() => {\n    let outsideEl = null\n\n    if (showLightBox && clickOutsideRef.current) {\n      outsideEl = clickOutsideRef.current\n      outsideEl.addEventListener(\"click\", function () {\n        setShowLightBox(false)\n      })\n    }\n\n    return (): void => {\n      outsideEl?.removeEventListener(\"click\", function () {\n        setShowLightBox(false)\n      })\n    }\n  }, [showLightBox])\n\n  if (!images?.length) return null\n\n  const lightBoxSection = (\n    <section\n      data-testid={`lightbox_main_section`}\n      className={cn(\n        \"bg-blackAlpha-900 pointer-events-none fixed inset-0 z-[60] flex flex-col items-center opacity-0 transition-all duration-300\",\n        showLightBox && \"pointer-events-auto opacity-100\"\n      )}\n    >\n      <header className=\"flex w-full items-center justify-between px-7 py-5\">\n        <h4 className=\"text-xl font-semibold text-white\">\n          {selectedImage?.title || selectedImage?.name}\n        </h4>\n        <div className=\"flex items-center justify-between space-x-1\">\n          <Button data-testid={`lightbox_button_goto_source`} className=\"p-0\">\n            <GetDocumentProxyUrl\n              url={selectedImage?.url}\n              item={(url) => {\n                return (\n                  <a\n                    href={url}\n                    className=\"flex h-full w-full items-center justify-center space-x-2 px-4 py-2 text-white\"\n                    target=\"_blank\"\n                    rel=\"noreferrer noopener\"\n                  >\n                    <span className=\"truncate\">Go to source</span>\n                    <StreamIcon path={mdiOpenInNew} />\n                  </a>\n                )\n              }}\n            />\n          </Button>\n          <Button\n            data-testid={`lightbox_button_close`}\n            className=\"border-none bg-transparent text-white hover:bg-transparent active:bg-transparent\"\n            variant=\"outline\"\n            onClick={handleCloseOnClick}\n          >\n            <StreamIcon path={mdiClose} />\n          </Button>\n        </div>\n      </header>\n      <div\n        ref={clickOutsideRef}\n        className=\"flex h-full w-full items-center justify-center px-10 py-8\"\n      >\n        <GetDocumentProxyUrl\n          url={selectedImage?.url}\n          item={(url) => {\n            return (\n              <img\n                data-testid={`lightbox_image`}\n                alt={selectedImage?.title}\n                src={url}\n              />\n            )\n          }}\n        />\n      </div>\n      <footer className=\"flex w-full items-center justify-center space-x-4 px-7 py-5\">\n        <Button\n          data-testid={`lightbox_button_prev`}\n          className=\"border-none bg-neutral-800 p-2 text-white hover:bg-neutral-800 active:bg-neutral-800\"\n          variant=\"outline\"\n          onClick={() => handleImageControlsOnClick(\"prev\")}\n        >\n          <StreamIcon path={mdiChevronLeft} />\n        </Button>\n        <span\n          data-testid={`lightbox_images_size`}\n          className=\"text-sm font-normal text-white\"\n        >\n          {imageIndex + 1} / {imagesLength}\n        </span>\n        <Button\n          data-testid={`lightbox_button_next`}\n          className=\"border-none bg-neutral-800 p-2 text-white hover:bg-neutral-800 active:bg-neutral-800\"\n          variant=\"outline\"\n          onClick={() => handleImageControlsOnClick(\"next\")}\n        >\n          <StreamIcon path={mdiChevronRight} />\n        </Button>\n      </footer>\n    </section>\n  )\n\n  return (\n    <>\n      <div\n        data-testid={`lightbox_container_images_preview`}\n        className={cn(\n          \"m-[6px] flex flex-wrap items-center\",\n          imagesContainerClassName\n        )}\n      >\n        {images\n          ?.filter((_, index) => index < MAX_PHOTOS)\n          .map(({ url, title }, index) => (\n            <div\n              key={`max_${index}`}\n              className={cn(\n                'after:content-[\" \"] after:hover:bg-neutral-fg relative z-0 m-[6px] h-auto w-[230px] cursor-pointer after:absolute after:inset-0 after:z-10',\n                imageContainerClassName\n              )}\n              onClick={() => handleOpenLightBoxOnClick(index)}\n            >\n              <GetDocumentProxyUrl\n                url={url}\n                item={(url) => {\n                  return (\n                    <img\n                      data-testid={`lightbox_image_preview_${index}`}\n                      className={cn(\"w-[230px]\", imageClassName)}\n                      alt={`${title} preview`}\n                      src={url}\n                    />\n                  )\n                }}\n              />\n            </div>\n          ))}\n        {images?.length > MAX_PHOTOS && (\n          <div\n            className={cn(\n              \"text-blackAlpha-600 bg-blackAlpha-200 hover:bg-neutral-fg z-0 m-[6px] flex h-[150px] w-[150px] cursor-pointer items-center justify-center self-center text-xl font-semibold\",\n              imageContainerClassName\n            )}\n            onClick={() => handleOpenLightBoxOnClick(MAX_PHOTOS)}\n          >\n            +{images?.length - MAX_PHOTOS}\n          </div>\n        )}\n      </div>\n      {createPortal(lightBoxSection, body)}\n    </>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/LightBox.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/Messages.tsx",
      "content": "import React, { useCallback, useEffect, useState } from \"react\"\nimport { mdiTextLong, mdiTuneVariant } from \"@mdi/js\"\nimport {\n  type ReferenceModel,\n  type ToolInvocation,\n  type ToolInvocationUIPart,\n} from \"@sitecore/stream-ui-core\"\nimport { useAtomValue } from \"jotai\"\n\nimport { Button } from \"@/registry/new-york/ui/button\"\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \"@/registry/new-york/ui/dialog\"\nimport { Tabs, TabsList, TabsTrigger } from \"@/registry/new-york/ui/tabs\"\n\nimport { cn } from \"../../lib/utils\"\nimport { ButtonScrollToBottom } from \"./ButtonScrollToBottom\"\nimport { EmptyScreen } from \"./EmptyScreen\"\nimport { Feedback } from \"./Feedback\"\nimport { useAiChatProvider } from \"./hooks/useAiChatProvider\"\nimport { useImageDropzone } from \"./hooks/useImageDropzone\"\nimport { useScrollAnchor } from \"./hooks/useScrollAnchor\"\nimport { Icon } from \"./Icon\"\nimport { PromptForm } from \"./PromptForm\"\nimport { isAnyArtifactOpenAtom } from \"./store/atoms\"\nimport { TOOL_ACTIONS, useToolDispatch } from \"./store/tools\"\nimport { type BrainstormingSearchTypeOptions } from \"./store/types\"\nimport { ToolInvocations } from \"./tools/ToolInvocations\"\nimport { type MessageAnnotation } from \"./types\"\nimport { UserMessage } from \"./UserMessage\"\n\nexport function Messages(): React.ReactNode {\n  /* Atoms */\n  const isAnyArtifactOpen = useAtomValue(isAnyArtifactOpenAtom)\n  const [toolState, dispatchToolAction] = useToolDispatch()\n\n  /* Hooks */\n  const { messages } = useAiChatProvider()\n  const { messagesRef, scrollRef, isAtBottom, scrollToBottom } =\n    useScrollAnchor(messages)\n  const [uploadedFiles, setUploadedFiles] = useState<File[]>([])\n\n  const handleSaveToolConfigurationOnClick = (\n    value: BrainstormingSearchTypeOptions\n  ) => {\n    dispatchToolAction({\n      type: TOOL_ACTIONS.CONFIGURE_BRAINSTORMING,\n      payload: { searchType: value },\n    })\n  }\n\n  const onDrop = useCallback((acceptedFiles: File[]) => {\n    setUploadedFiles((prevFiles) => [...prevFiles, ...acceptedFiles])\n  }, [])\n\n  const onClearFiles = useCallback(() => {\n    setUploadedFiles([])\n  }, [])\n\n  // Remaining upload slots; note: react-dropzone treats maxFiles=0 as \"unlimited\",\n  // so we clamp to at least 1 and explicitly disable when no slots remain.\n  const remainingSlots = Math.max(0, 10 - uploadedFiles.length)\n\n  const { getRootProps, getInputProps, isDragActive } = useImageDropzone({\n    enabled: true,\n    currentCount: uploadedFiles.length,\n    maxTotal: 10,\n    maxSizeBytes: 5 * 1024 * 1024,\n    onFilesAccepted: (files) => onDrop(files),\n  })\n\n  /* Will run when scroll changes */\n  useEffect(() => {\n    if (scrollRef.current) {\n      scrollRef.current.scrollTop = scrollRef.current.scrollHeight\n    }\n  }, [messages, scrollRef])\n\n  const shouldShowExamplePrompts = !messages?.length\n\n  return (\n    <div\n      className=\"relative flex h-screen flex-1 overflow-hidden bg-[#FBFBFB]\"\n      {...getRootProps()}\n    >\n      <input {...getInputProps()} />\n      {isDragActive && (\n        <div className=\"pointer-events-none absolute inset-0 z-20 grid place-items-center bg-white/40 backdrop-blur-sm\">\n          <div className=\"text-center\">\n            <div className=\"relative mx-auto h-24 w-32\">\n              <img\n                src=\"https://delivery-sitecore.sitecorecontenthub.cloud/api/public/content/spot-drag-items\"\n                alt=\"Drag items illustration\"\n                width={400}\n                height={400}\n              />\n            </div>\n            <h2 className=\"text-2xl font-bold\">Drag & drop</h2>\n            <p className=\"text-subtle-text text-lg\">\n              Drop your assets to use them as context\n            </p>\n          </div>\n        </div>\n      )}\n      <div className=\"relative flex h-screen flex-1 flex-col gap-4 px-6 pt-6\">\n        <Dialog>\n          <DialogTrigger\n            id=\"tour-chat-brainstorming-tools-settings\"\n            className=\"absolute top-[-6px] right-[16px] z-10\"\n            asChild\n          >\n            <Button\n              data-testid=\"brainstorming_button_tool_configuration\"\n              variant={\"ghost\"}\n              colorScheme={\"neutral\"}\n              size={\"icon-sm\"}\n              title=\"Tool configuration\"\n            >\n              <Icon path={mdiTuneVariant} />\n            </Button>\n          </DialogTrigger>\n\n          <DialogContent className=\"flex flex-col gap-4\">\n            <DialogHeader className=\"gap-2\">\n              <DialogTitle>Tool configuration</DialogTitle>\n              <DialogDescription>\n                Tune and configure how each tool handles your chats, retrieves\n                information and outputs responses\n              </DialogDescription>\n            </DialogHeader>\n            <div className=\"space-y-2\">\n              <h2 className=\"text-md text-blackAlpha-600\">Tools</h2>\n              <div className=\"space-y-2 rounded-md bg-gray-50 p-2\">\n                <div className=\"flex items-center gap-2\">\n                  <div className=\"bg-primary-100 inline-block rounded p-1\">\n                    <Icon\n                      path={mdiTextLong}\n                      className=\"text-primary-600\"\n                      size={\"xs\"}\n                    />\n                  </div>\n                  <span className=\"font-bold\">Brainstorming</span>\n                </div>\n                <div className=\"space-y-2 px-10\">\n                  <h2 className=\"text-md text-blackAlpha-600\">\n                    Default search type\n                  </h2>\n                  <Tabs\n                    className=\"w-fit\"\n                    defaultValue={\n                      toolState.brainstorming.data?.params?.searchType ??\n                      \"knowledge_web\"\n                    }\n                    onValueChange={(value) =>\n                      handleSaveToolConfigurationOnClick(\n                        value as BrainstormingSearchTypeOptions\n                      )\n                    }\n                  >\n                    <TabsList className=\"border-blackAlpha-200 rounded-md border p-1\">\n                      <TabsTrigger\n                        className=\"data-[state=active]:bg-primary-100 w-fit rounded-md border-none\"\n                        value=\"knowledge_web\"\n                      >\n                        Knowledge & web\n                      </TabsTrigger>\n                      <TabsTrigger\n                        className=\"data-[state=active]:bg-primary-100 w-fit rounded-md border-none\"\n                        value=\"knowledge\"\n                      >\n                        Knowledge search\n                      </TabsTrigger>\n                      <TabsTrigger\n                        className=\"data-[state=active]:bg-primary-100 w-fit rounded-md border-none\"\n                        value=\"web\"\n                      >\n                        Web search\n                      </TabsTrigger>\n                    </TabsList>\n                  </Tabs>\n                </div>\n              </div>\n            </div>\n          </DialogContent>\n        </Dialog>\n        <div\n          className=\"relative z-0 mb-[125px] flex min-h-0 flex-grow flex-col gap-4 overflow-auto\"\n          ref={scrollRef}\n          data-testid=\"scroll-contain-base-chat\"\n        >\n          {shouldShowExamplePrompts && <EmptyScreen />}\n          <div className=\"space-y-4\" ref={messagesRef}>\n            {messages?.map((message, messageIndex, messagesArray) => {\n              /* The message ID is found in the annotation array. The id you see in the response object is the db id */\n              const messageId = (\n                message?.annotations?.[0] as unknown as MessageAnnotation\n              )?.id\n\n              const isLastMessage = messageIndex === messagesArray.length - 1\n\n              const toolInvocations = (\n                message.parts as ToolInvocationUIPart[] | undefined\n              )\n                ?.filter(\n                  (part: ToolInvocationUIPart) =>\n                    part.type === \"tool-invocation\"\n                )\n                .map(\n                  (part: ToolInvocationUIPart) => part.toolInvocation\n                ) as (ToolInvocation & {\n                reference: ReferenceModel\n              })[]\n\n              const areToolInvocationsAvailable = !!toolInvocations?.length\n\n              const previousMessageContent = Array.isArray(\n                messages[messages.length - 2]?.content\n              )\n                ? (\n                    messages[messages.length - 2]?.content as unknown as {\n                      value: string\n                    }[]\n                  )?.[0]?.value\n                : messages[messages.length - 2]?.content\n\n              return (\n                <div\n                  key={`${message.id}_${messageIndex}`}\n                  className={cn(\"stream-chat-container space-y-4\", {\n                    \"pb-4\": messageIndex % 2 !== 0 && !isLastMessage,\n                  })}\n                >\n                  {message.role === \"user\" && (\n                    <UserMessage>{message.content}</UserMessage>\n                  )}\n                  {message.role === \"assistant\" && (\n                    <>\n                      {areToolInvocationsAvailable && (\n                        <>\n                          <ToolInvocations\n                            messageId={messageId}\n                            message={message}\n                            toolInvocations={toolInvocations}\n                            isLastMessage={isLastMessage}\n                          />\n                          <Feedback\n                            messageId={messageId}\n                            message={message}\n                            isLastMessage={isLastMessage}\n                            previousMessageContent={previousMessageContent}\n                          />\n                        </>\n                      )}\n                    </>\n                  )}\n                </div>\n              )\n            })}\n          </div>\n        </div>\n        <div className=\"relative bottom-[125px] z-10 flex flex-shrink-0 flex-col gap-4 bg-[#FBFBFB]\">\n          <ButtonScrollToBottom\n            isAtBottom={isAtBottom}\n            scrollToBottom={scrollToBottom}\n          />\n\n          <div className=\"stream-chat-container\">\n            <PromptForm\n              uploadedFiles={uploadedFiles}\n              onFileRemove={(file) => {\n                setUploadedFiles((prevFiles) =>\n                  prevFiles.filter((f) => f !== file)\n                )\n              }}\n              onFileUpload={(files) => {\n                setUploadedFiles((prevFiles) => [...prevFiles, ...files])\n              }}\n              onClearFiles={onClearFiles}\n            />\n          </div>\n        </div>\n      </div>\n      <aside\n        id=\"artifactsPortalPlaceholder\"\n        className={cn(\n          \"z-10 basis-1/2 overflow-hidden transition-all duration-300\",\n          {\n            \"mr-0\": isAnyArtifactOpen,\n            \"-mr-[50%]\": !isAnyArtifactOpen,\n          }\n        )}\n      />\n    </div>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/Messages.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/Markdown.tsx",
      "content": "import React from \"react\"\nimport ReactMarkdown from \"react-markdown\"\nimport remarkGfm from \"remark-gfm\"\nimport remarkMath from \"remark-math\"\n\nimport { cn } from \"../../lib/utils\"\nimport { GetDocumentProxyUrl } from \"./GetDocumentProxyUrl\"\n\nexport interface MarkdownProps {\n  id?: string\n  text: string\n  className?: string\n  componentClassName?: string\n}\n\nexport function Markdown({\n  id,\n  text = \"\",\n  className = \"\",\n  componentClassName = \"\",\n}: MarkdownProps): React.ReactNode {\n  return (\n    <div\n      data-testid={`markdown-container-div-${id}`}\n      id={id}\n      className=\"h-full w-full\"\n    >\n      <ReactMarkdown\n        className={cn(\n          \"prose dark:prose-invert prose-p:leading-relaxed prose-pre:p-0 max-w-full break-words\",\n          className\n        )}\n        remarkPlugins={[remarkGfm, remarkMath]}\n        components={{\n          p({ children }) {\n            return (\n              <div className={cn(\"mb-2\", componentClassName)}>{children}</div>\n            )\n          },\n\n          img({ src, ...rest }) {\n            return (\n              <div className=\"mb-2 bg-gray-50 py-2\">\n                <GetDocumentProxyUrl\n                  url={src as string}\n                  item={(url) => {\n                    return (\n                      <img\n                        {...rest}\n                        contentEditable={false}\n                        alt={rest.alt || \"\"}\n                        src={url}\n                        height={400}\n                        className=\"mx-auto my-0 w-full max-w-2xl\"\n                      />\n                    )\n                  }}\n                />\n              </div>\n            )\n          },\n\n          a({ href, ...rest }) {\n            return (\n              <GetDocumentProxyUrl\n                url={href!}\n                item={(url) => {\n                  return (\n                    <a\n                      {...rest}\n                      contentEditable={false}\n                      href={url}\n                      rel=\"noopener noreferrer\"\n                      target=\"_blank\"\n                      className=\"text-md text-subtle-text underline underline-offset-2\"\n                    />\n                  )\n                }}\n              />\n            )\n          },\n        }}\n      >\n        {text}\n      </ReactMarkdown>\n    </div>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/Markdown.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/MessageFeedback.tsx",
      "content": "import React, { useMemo, useState } from \"react\"\nimport { type ToolInvocationUIPart, type UIMessage } from \"@ai-sdk/ui-utils\"\nimport { mdiThumbDownOutline, mdiThumbUpOutline } from \"@mdi/js\"\nimport {\n  chat,\n  type ContentModelRead,\n  type FeedbackModel,\n  type ListUserChatMessagesModelResponseV2,\n  type UpdateUserChatMessageModelResponseV2,\n} from \"@sitecore/stream-ui-core\"\nimport { useAtomValue } from \"jotai\"\nimport { isEmpty } from \"lodash\"\nimport { toast } from \"sonner\"\n\nimport { Button } from \"@/registry/new-york/ui/button\"\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger,\n} from \"@/registry/new-york/ui/tooltip\"\n\nimport { cn } from \"../../lib/utils\"\nimport { StreamIcon } from \"../../ui/stream-icon\"\nimport { ActionModal } from \"./ActionModal\"\nimport { useChatProvider } from \"./hooks/useChatProvider\"\nimport { SourceItem } from \"./SourceItem\"\nimport { chatIdAtom, extractSourcesFromDataAtom } from \"./store/atoms\"\nimport { type ExtractSourceProps, type HTTPValidationError } from \"./types\"\nimport {\n  createSources,\n  extractSourcesFromBrainstorming,\n  extractSourcesFromParts,\n} from \"./utils\"\n\nexport interface MessageFeedbackProps {\n  message: UIMessage &\n    Pick<ListUserChatMessagesModelResponseV2, \"feedback\"> & {\n      content?: string | Array<ContentModelRead>\n    }\n  messageId: string\n}\n\nconst feedbackConfig = [\n  { type: \"good\", activeColor: \"text-green-300\", icon: mdiThumbUpOutline },\n  { type: \"bad\", activeColor: \"text-red-300\", icon: mdiThumbDownOutline },\n]\n\nexport function MessageFeedback({\n  messageId,\n  message,\n}: MessageFeedbackProps): React.ReactNode {\n  /* Hooks */\n  const { session } = useChatProvider()\n  const [rollbackFeedback, setRollbackFeedback] =\n    useState<FeedbackModel | null>(message?.feedback ?? null)\n  const [feedback, setFeedback] = useState<FeedbackModel | null>(\n    message?.feedback ?? null\n  )\n\n  /* Atoms */\n  const extractSourcesFromData = useAtomValue(extractSourcesFromDataAtom)\n  const chatId = useAtomValue(chatIdAtom)\n\n  /* Computed */\n  const parts = message?.parts as ToolInvocationUIPart[]\n  const allSources = useMemo(\n    () =>\n      createSources(\n        extractSourcesFromData?.[messageId] ?? {},\n        extractSourcesFromBrainstorming(parts),\n        extractSourcesFromParts(parts)\n      ),\n    [extractSourcesFromData, messageId, parts]\n  )\n  const allSourcesTotalAmount = useMemo(\n    () =>\n      allSources?.reduce(\n        (acc: number, cur: ExtractSourceProps) => acc + cur[1].length,\n        0\n      ),\n    [allSources]\n  )\n\n  const onFeedbackClick = async (\n    type: FeedbackModel[\"type\"]\n  ): Promise<void> => {\n    const hasFeedback = feedback?.type === type\n    let updatedMessage: UpdateUserChatMessageModelResponseV2 | undefined\n\n    setFeedback((prev) => (hasFeedback ? null : { ...prev, type }))\n\n    try {\n      const { data } =\n        await chat.getUserChatMessageV2ApiChatsV2OrganizationsOrganizationIdUsersUserIdChatsChatIdMessagesMessageIdGet(\n          {\n            path: {\n              messageId,\n              userId: session.userId,\n              chatId,\n              organizationId: session.orgId,\n            },\n          }\n        )\n\n      const patchMessageRes = await fetch(\n        `https://ai-chat-api-${session.apiEnv}/api/chats/v2/organizations/${session.orgId}/users/${session.userId}/chats/${chatId}/messages/${messageId}`,\n        {\n          method: \"PATCH\",\n          body: JSON.stringify({\n            content: data?.content ?? null,\n            feedback: hasFeedback ? null : { type },\n          }),\n          headers: {\n            \"Content-Type\": \"application/json\",\n            ...(session?.token\n              ? { Authorization: `Bearer ${session?.token}` }\n              : {}),\n          },\n        }\n      )\n\n      if (!patchMessageRes.ok) {\n        throw patchMessageRes\n      }\n\n      updatedMessage = await patchMessageRes.json()\n      setRollbackFeedback(updatedMessage?.feedback ?? null)\n      setFeedback(updatedMessage?.feedback ?? null)\n    } catch (error) {\n      const { detail } = error as HTTPValidationError\n      setFeedback(rollbackFeedback)\n      toast.error(detail[0]?.msg)\n    }\n  }\n\n  return (\n    <div className=\"flex gap-1\">\n      {feedbackConfig.map((btn, index) => (\n        <Tooltip key={`${btn.type}_${index}`}>\n          <TooltipTrigger asChild>\n            <Button\n              data-testid={`feedback_button_${btn.type}`}\n              variant=\"ghost\"\n              colorScheme=\"neutral\"\n              className={cn(\n                feedback?.type === btn.type ? btn.activeColor : \"gray\"\n              )}\n              size=\"icon\"\n              disabled={!message?.id}\n              onClick={() => onFeedbackClick(btn.type as FeedbackModel[\"type\"])}\n            >\n              <StreamIcon path={btn.icon} />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent className=\"text-inverse-text max-w-[200px] bg-gray-700 text-sm shadow-md\">\n            Tell us whether you got a quality result. This will be logged for\n            review to help us improve our AI\n          </TooltipContent>\n        </Tooltip>\n      ))}\n      {/* TODO might re-visit */}\n      {/*<Button variant=\"ghost\" colorScheme=\"gray\" size=\"icon\" disabled>\n        <Icon path={mdiRestart} />\n      </Button>*/}\n      {!isEmpty(allSources) && (\n        <ActionModal\n          ctaTitle=\"Sources\"\n          modalTitle={`Sources (${allSourcesTotalAmount})`}\n        >\n          {allSources?.map((sources, index: number) => (\n            <SourceItem\n              key={`sources_item_${index}_${message.id}`}\n              sources={sources}\n            />\n          ))}\n        </ActionModal>\n      )}\n    </div>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/MessageFeedback.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/EmptyScreen.tsx",
      "content": "import { memo } from \"react\"\n\nimport { EmptyScreenBoxes } from \"./EmptyScreenBoxes\"\n\nexport const EmptyScreen = memo(function EmptyScreen() {\n  return (\n    <div className=\"chat-container flex flex-1 flex-col items-center justify-center\">\n      <div className=\"flex flex-wrap gap-4\">\n        <h2 className=\"bg-ai-400 inline-block bg-clip-text text-5xl font-semibold text-transparent\">\n          How can I help?\n        </h2>\n        <EmptyScreenBoxes />\n      </div>\n    </div>\n  )\n})\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/EmptyScreen.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/EmptyScreenBoxes.tsx",
      "content": "\"use client\"\n\nimport { memo, type JSX } from \"react\"\nimport {\n  mdiAccountBadgeOutline,\n  mdiArrowBottomRight,\n  mdiChatOutline,\n  mdiFileDocument,\n  mdiHeadLightbulb,\n  mdiLightbulbOnOutline,\n} from \"@mdi/js\"\nimport { useAtom } from \"jotai\"\n\nimport { cn } from \"@/lib/utils\"\n\nimport { useAiChatProvider } from \"../chat/hooks/useAiChatProvider\"\nimport { Icon } from \"../chat/Icon\"\nimport { configAtom } from \"./store/atoms\"\n\nexport type ExamplePrompt = {\n  icon: JSX.Element\n  content: string\n}\n\nconst ExamplePrompts: ExamplePrompt[] = [\n  {\n    icon: (\n      <Icon\n        path={mdiAccountBadgeOutline}\n        className=\"text-3xl text-purple-500\"\n      />\n    ),\n    content: \"Who is our target consumer?\",\n  },\n  {\n    icon: <Icon path={mdiChatOutline} className=\"text-3xl text-rose-600\" />,\n    content: \"Can you describe to me our brand tone of voice?\",\n  },\n  {\n    icon: (\n      <Icon path={mdiLightbulbOnOutline} className=\"text-3xl text-green-300\" />\n    ),\n    content: \"What is our brand big idea?\",\n  },\n  {\n    icon: <Icon path={mdiHeadLightbulb} className=\"text-3xl text-blue-400\" />,\n    content: \"Brainstorm some headline ideas for my new campaign\",\n  },\n  {\n    icon: <Icon path={mdiFileDocument} className=\"text-3xl text-yellow-400\" />,\n    content: \"Create a brief for my new campaign targeting my consumers\",\n  },\n]\n\nexport type MemoizedEmptyScreenBoxes = {\n  setInput: React.Dispatch<React.SetStateAction<string>>\n  brandKitStateId: string\n}\n\nexport const EmptyScreenBoxes = () => {\n  const { setInput } = useAiChatProvider()\n\n  return <MemoizedEmptyScreenBoxes {...{ setInput, brandKitStateId: \"\" }} />\n}\n\nconst MemoizedEmptyScreenBoxes = memo(function MemoizedEmptyScreenBoxes({\n  setInput,\n  brandKitStateId,\n}: MemoizedEmptyScreenBoxes) {\n  const [config] = useAtom(configAtom)\n\n  const isBrandkitIdAvailable = !!brandKitStateId?.length\n\n  const onClick = (content: string) => {\n    setInput(content)\n  }\n\n  const Prompts = config?.examplePrompts?.length\n    ? config.examplePrompts\n    : ExamplePrompts\n\n  return (\n    <div className=\"grid grid-cols-3 items-stretch gap-4 p-1\">\n      {Prompts.map(({ content, icon }, index) => (\n        <button\n          key={`${content}}-${index}`}\n          className={cn(\n            \"text-body-text flex w-full flex-col items-center justify-between gap-5 rounded-xl bg-gray-50 p-5 hover:bg-gray-100\",\n            {\n              \"col-span-2\": index === Prompts.length - 1,\n            }\n          )}\n          onClick={() => onClick(content)}\n        >\n          <p className=\"text-body-text m-0 line-clamp-3 text-center text-lg\">\n            {content}\n          </p>\n\n          <div className=\"flex w-full\">\n            {icon ? (\n              icon\n            ) : (\n              <Icon\n                path={mdiArrowBottomRight}\n                className=\"text-md neutral-fg ml-auto\"\n              />\n            )}\n          </div>\n        </button>\n      ))}\n    </div>\n  )\n})\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/EmptyScreenBoxes.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/MessageSubtitle.tsx",
      "content": "import React from \"react\"\nimport { mdiLoading, mdiStarFourPoints } from \"@mdi/js\"\n\nimport { cn } from \"../../lib/utils\"\nimport { StreamIcon } from \"../../ui/stream-icon\"\n\nexport interface MessageSubtitleProps {\n  icon?: string\n  title?: string\n  size?: \"sm\" | \"lg\"\n  className?: string\n  isGenerating?: boolean\n}\n\nexport function MessageSubtitle({\n  icon,\n  title,\n  size = \"lg\",\n  className,\n  isGenerating,\n}: MessageSubtitleProps): React.ReactNode {\n  return (\n    <div\n      data-testid={`message_subtitle_${title?.split(\" \").join(\"_\").toLowerCase()}`}\n      className={cn(\n        \"subtle-text mb-3 flex items-center gap-3 font-semibold\",\n        size === \"sm\" ? \"text-sm\" : \"text-lg\",\n        className\n      )}\n    >\n      {isGenerating ? (\n        <StreamIcon path={mdiLoading} className=\"animate-spin\" />\n      ) : (\n        icon &&\n        (icon === \"sparkle\" ? (\n          <StreamIcon\n            path={mdiStarFourPoints}\n            size=\"xs\"\n            className=\"text-md text-current\"\n          />\n        ) : (\n          <StreamIcon path={icon} className=\"text-md h-6 w-6\" />\n        ))\n      )}\n      {title || \"\"}\n    </div>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/MessageSubtitle.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/PromptForm.tsx",
      "content": "import React, { useEffect, useMemo, useRef, useState } from \"react\"\nimport {\n  mdiClose,\n  mdiPaperclip,\n  mdiPlus,\n  mdiSend,\n  mdiStop,\n  mdiStopCircleOutline,\n} from \"@mdi/js\"\nimport { chat as chatApi, HTTPError } from \"@sitecore/stream-ui-core\"\nimport { useAtom, useAtomValue, useSetAtom } from \"jotai\"\nimport Textarea from \"react-textarea-autosize\"\nimport { toast } from \"sonner\"\n\nimport { Button } from \"@/registry/new-york/ui/button\"\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/registry/new-york/ui/popover\"\n\nimport { useBrandkitById } from \"../../hooks/use-brandkit-by-id\"\nimport { cn } from \"../../lib/utils\"\nimport {\n  chatIdAtom,\n  configAtom,\n  isChatActionPendingAtom,\n  isLoadingAtom,\n  isNewChatAtom,\n  postChatGenerateBodyAtom,\n} from \"../chat/store/atoms\"\nimport { useAiChatProvider } from \"./hooks/useAiChatProvider\"\nimport { useChatProvider } from \"./hooks/useChatProvider\"\nimport { useEnterSubmit } from \"./hooks/useEnterSubmit\"\nimport { useImageDropzone } from \"./hooks/useImageDropzone\"\nimport { useLocalStorage } from \"./hooks/useLocalStorage\"\nimport { Icon } from \"./Icon\"\nimport { toolList } from \"./store/toolDefinitions\"\nimport {\n  activeToolDataAtom,\n  activeToolNameAtom,\n  isAnyToolActiveAtom,\n  useToolDispatch,\n  type ToolAction,\n} from \"./store/tools\"\nimport { ReferencesBuilder } from \"./utils/referencesBuilder\"\n\nexport type PromptFormProps = {\n  uploadedFiles?: File[]\n  onFileRemove?: (file: File) => void\n  onFileUpload?: (files: File[]) => void\n  onClearFiles?: () => void\n}\n\nasync function fileToDataURL(file: File): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader()\n    reader.onerror = () => reject(reader.error)\n    reader.onload = () => resolve(String(reader.result))\n    reader.readAsDataURL(file)\n  })\n}\n\nexport function PromptForm({\n  uploadedFiles,\n  onFileRemove,\n  onFileUpload,\n  onClearFiles,\n}: PromptFormProps) {\n  const { session } = useChatProvider()\n  const {\n    input,\n    handleSubmit,\n    handleInputChange,\n    rollbackChatChanges,\n    brandkitId,\n  } = useAiChatProvider()\n  const { formRef, onKeyDown } = useEnterSubmit()\n  const [isMultiline, setIsMultiline] = useState(false)\n  // Stream components use all tools without feature flag filtering\n  const availableTools = toolList\n\n  const [, dispatchToolAction] = useToolDispatch()\n  const isAnyToolActive = useAtomValue(isAnyToolActiveAtom)\n  const activeToolName = useAtomValue(activeToolNameAtom)\n  const activeToolData = useAtomValue(activeToolDataAtom)\n  const { brandkit } = useBrandkitById(brandkitId, {\n    organizationId: session.orgId,\n    includeDeleted: true,\n  })\n  const isBrandkitDelete = useMemo(() => !!brandkit?.deletedAt, [brandkit])\n  const [isProcessing] = useState<{ [key: string]: boolean }>({})\n  const btnRef = useRef<HTMLButtonElement>(null)\n\n  /* Atoms */\n  const [isChatActionPending, setIsChatActionPending] = useAtom(\n    isChatActionPendingAtom\n  )\n  const isLoading = useAtomValue(isLoadingAtom)\n  const setChatBodyAtom = useSetAtom(postChatGenerateBodyAtom)\n  const config = useAtomValue(configAtom)\n  const [chatId, setChatId] = useAtom(chatIdAtom)\n  const setIsNewChat = useSetAtom(isNewChatAtom)\n\n  /* Computed */\n  const isProcessingAllChanges = Object.values(isProcessing).some((v) => v)\n\n  const referencesArr = useRef<never[]>([])\n\n  const [, setLocalStorageRefs] = useLocalStorage(\n    \"promptFormRefs\",\n    referencesArr.current\n  )\n\n  const isBrandkitIdAvailable = !!brandkitId?.length\n  const isPromptDisabled =\n    !isBrandkitIdAvailable ||\n    isLoading ||\n    isBrandkitDelete ||\n    isChatActionPending\n\n  const {\n    open: openFileDialog,\n    getInputProps,\n    remainingSlots,\n  } = useImageDropzone({\n    enabled: true,\n    currentCount: uploadedFiles?.length ?? 0,\n    maxTotal: 10,\n    maxSizeBytes: 5 * 1024 * 1024,\n    onFilesAccepted: (files) => onFileUpload?.(files),\n  })\n\n  const onHeight = () => {\n    setIsMultiline(true)\n  }\n\n  const setChatData = async (cb?: () => void) => {\n    const filesToUpload = await Promise.all(\n      (uploadedFiles || []).map(async (file) => {\n        const dataUrl = await fileToDataURL(file)\n        return {\n          type: \"image_base64\",\n          value: dataUrl,\n        }\n      })\n    )\n\n    // Get current tool data for submission from any active tool\n    const toolData = activeToolData\n\n    // Now that all files are uploaded and we have their IDs, call handleSubmit\n    const data = {\n      content: input,\n      references: [\n        ...ReferencesBuilder({ orgId: session.orgId, userId: session.userId })\n          .addBrandkit({ id: brandkitId!, isArtefact: false })\n          .build(),\n        ...referencesArr.current,\n      ],\n      ...(toolData || {}),\n      addedContext: filesToUpload,\n    }\n\n    setChatBodyAtom(data)\n    cb?.()\n    referencesArr.current = []\n    onClearFiles?.()\n  }\n\n  const handleOnSubmit = async (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault()\n\n    if (!brandkitId || !input) return\n\n    if (!chatId) {\n      setLocalStorageRefs(referencesArr.current)\n      setIsChatActionPending(true)\n\n      try {\n        const { data } =\n          await chatApi.createUserChatV2ApiChatsV2OrganizationsOrganizationIdUsersUserIdChatsPost(\n            {\n              path: {\n                userId: session.userId,\n                organizationId: session.orgId,\n              },\n              body: {\n                title: input,\n                references: ReferencesBuilder({\n                  orgId: session.orgId,\n                  userId: session.userId,\n                })\n                  .addBrandkit({ id: brandkitId, isArtefact: false })\n                  .build() as never,\n              },\n            }\n          )\n        setChatData(() => {\n          setChatId(data?.id as string)\n          setIsNewChat(true)\n        })\n        return\n      } catch (error: unknown) {\n        const { response } = error as HTTPError\n        toast.error(response.statusText)\n      } finally {\n        setIsChatActionPending(false)\n      }\n    }\n\n    setChatData(() => handleSubmit?.())\n  }\n\n  const handleFileUpload = () => {\n    // If no slots remain, show immediate feedback and skip opening dialog\n    if (remainingSlots === 0) {\n      toast.error(\"You can only upload up to 10 files.\")\n      return\n    }\n    openFileDialog()\n  }\n\n  const onStopGeneration = () => {\n    if (!chatId) return\n\n    rollbackChatChanges()\n  }\n\n  // Universal tool handler using useReducerAtom\n  const handleToolClick = (action: ToolAction) => {\n    dispatchToolAction(action)\n  }\n\n  // Memoize object URLs for previews so typing doesn't recreate them every render\n  const filePreviews = useMemo(\n    () =>\n      (uploadedFiles || []).map((file, index) => {\n        const isImage = file.type.startsWith(\"image/\")\n        // Only create a blob URL for images; non-images use a static icon path\n        const url = isImage ? URL.createObjectURL(file) : \"/icons/file-icon.svg\"\n        const key = `${file.name}-${file.size}-${file.lastModified}-${index}`\n        return { key, file, isImage, url } as const\n      }),\n    [uploadedFiles]\n  )\n\n  // Revoke previous object URLs on change/unmount to prevent leaks and reloads\n  useEffect(() => {\n    return () => {\n      for (const p of filePreviews) {\n        if (p.isImage) {\n          URL.revokeObjectURL(p.url)\n        }\n      }\n    }\n  }, [filePreviews])\n\n  return (\n    <form ref={formRef} className=\"w-full space-y-2\" onSubmit={handleOnSubmit}>\n      <input {...getInputProps()} style={{ display: \"none\" }} />\n      <div\n        className={cn(\n          \"stream-bg-ai-400 w-full rounded-full p-[2px]\",\n          isMultiline ? \"rounded-2xl\" : \"rounded-full\"\n        )}\n      >\n        <div\n          className={cn(\n            \"relative flex w-full flex-col gap-1.5 rounded-full bg-white p-2\",\n            {\n              \"ai-textbox-expanded-border-radius\": isMultiline,\n              \"rounded-full\": !isMultiline,\n              \"bg-gray-50\": isPromptDisabled || isChatActionPending,\n            }\n          )}\n        >\n          <Textarea\n            data-testid=\"prompt_form_textarea\"\n            disabled={isPromptDisabled || isChatActionPending}\n            tabIndex={0}\n            onKeyDown={onKeyDown}\n            onHeightChange={onHeight}\n            placeholder=\"Ask anything\"\n            className={cn(\n              \"ai-textbox-scrollbar sm:text-md w-full flex-grow resize-none bg-transparent px-3 py-2 text-sm focus-within:outline-none\"\n            )}\n            autoFocus\n            spellCheck={false}\n            autoComplete=\"off\"\n            autoCorrect=\"off\"\n            maxRows={7}\n            name=\"prompt\"\n            value={input}\n            onChange={(e) => {\n              if (isProcessingAllChanges) {\n                e.preventDefault()\n              }\n              handleInputChange?.(e)\n            }}\n          />\n          <div\n            className={cn(\n              \"flex items-end justify-between bg-transparent focus-visible:outline-none\",\n              isMultiline ? \"bottom-2\" : \"top-[50%] translate-y-[-50%]\"\n            )}\n          >\n            <div className=\"flex flex-grow flex-wrap gap-1\">\n              {availableTools.length > 0 && (\n                <>\n                  {!isAnyToolActive && (\n                    <Popover>\n                      <PopoverTrigger asChild>\n                        <Button\n                          id=\"tour-chat-brainstorming-tools\"\n                          variant=\"ghost\"\n                          colorScheme=\"neutral\"\n                        >\n                          <Icon path={mdiPlus} /> <span>Tools</span>\n                        </Button>\n                      </PopoverTrigger>\n                      <PopoverContent\n                        side=\"top\"\n                        align=\"start\"\n                        className=\"flex w-56 flex-col gap-2 p-2\"\n                      >\n                        {availableTools.map((tool) => (\n                          <button\n                            key={tool.key}\n                            className=\"flex gap-2 rounded-md p-2 text-left transition-colors hover:bg-gray-50\"\n                            onClick={() =>\n                              handleToolClick({ type: tool.action })\n                            }\n                          >\n                            <Icon\n                              path={tool.icon}\n                              size={\"2xs\"}\n                              className=\"text-blackAlpha-500\"\n                            />\n                            <div>\n                              <h3 className=\"text-sm font-semibold\">\n                                {tool.name}\n                              </h3>\n                              <p className=\"text-blackAlpha-300 text-sm\">\n                                {tool.description}\n                              </p>\n                            </div>\n                          </button>\n                        ))}\n\n                        <p className=\"text-muted-fg px-2 py-0.5 text-sm\">\n                          More tools coming soon\n                        </p>\n                      </PopoverContent>\n                    </Popover>\n                  )}\n                  {isAnyToolActive &&\n                    activeToolName &&\n                    (() => {\n                      const activeTool = availableTools.find(\n                        (tool) => tool.key === activeToolName\n                      )\n                      return activeTool ? (\n                        <Button\n                          onClick={() =>\n                            handleToolClick({ type: activeTool.action })\n                          }\n                          variant={\"outline\"}\n                          className={cn(\"\", activeToolName && \"bg-primary-200\")}\n                        >\n                          <Icon path={activeTool.icon} size={\"2xs\"} />{\" \"}\n                          <span>{activeTool.name}</span>\n                        </Button>\n                      ) : null\n                    })()}\n                </>\n              )}\n              <div className=\"mr-1 flex flex-grow items-center justify-end gap-2\">\n                {filePreviews.slice(0, 2).map((p) => {\n                  return (\n                    <div\n                      key={p.key}\n                      className=\"group relative flex h-8 max-w-44 items-center justify-center gap-2 rounded border p-1\"\n                      title={p.file.name}\n                    >\n                      <div className=\"relative size-6 shrink-0 overflow-hidden rounded-sm bg-gray-100 ring-1 ring-black/5\">\n                        {p.isImage ? (\n                          <>\n                            <img\n                              src={p.url}\n                              alt=\"\"\n                              className=\"scale-110 object-cover opacity-50 blur-sm\"\n                              sizes=\"28px\"\n                              aria-hidden\n                            />\n                            <img\n                              src={p.url}\n                              alt={p.file.name}\n                              className=\"object-contain\"\n                              sizes=\"28px\"\n                            />\n                          </>\n                        ) : (\n                          <img\n                            src=\"/icons/file-icon.svg\"\n                            alt=\"\"\n                            className=\"object-contain\"\n                            sizes=\"28px\"\n                          />\n                        )}\n                      </div>\n                      <span className=\"truncate\">{p.file.name}</span>\n                      <div\n                        className=\"absolute top-1/2 right-2 hidden size-5 -translate-y-1/2 cursor-pointer place-items-center bg-white group-hover:grid\"\n                        onClick={() => onFileRemove?.(p.file)}\n                      >\n                        <Icon\n                          path={mdiClose}\n                          className=\"text-blackAlpha-500 hover:text-blackAlpha-700\"\n                          size={\"2xs\"}\n                        />\n                      </div>\n                    </div>\n                  )\n                })}\n\n                {filePreviews && filePreviews.length > 2 && (\n                  <Popover>\n                    <PopoverTrigger asChild>\n                      <button className=\"grid h-8 w-9 place-items-center rounded border\">\n                        +{filePreviews.length - 2}\n                      </button>\n                    </PopoverTrigger>\n\n                    <PopoverContent align=\"end\" className=\"w-80 space-y-2 p-2\">\n                      {filePreviews.slice(2).map((p) => {\n                        return (\n                          <div\n                            key={p.key}\n                            className=\"group relative flex h-8 w-full items-center gap-2 rounded border p-1\"\n                            title={p.file.name}\n                          >\n                            <div className=\"relative size-6 shrink-0 overflow-hidden rounded-sm bg-gray-100 ring-1 ring-black/5\">\n                              {p.isImage ? (\n                                <>\n                                  <img\n                                    src={p.url}\n                                    alt=\"\"\n                                    className=\"scale-110 object-cover opacity-50 blur-sm\"\n                                    sizes=\"28px\"\n                                    aria-hidden\n                                  />\n                                  <img\n                                    src={p.url}\n                                    alt={p.file.name}\n                                    className=\"object-contain\"\n                                    sizes=\"28px\"\n                                  />\n                                </>\n                              ) : (\n                                <img\n                                  src=\"/icons/file-icon.svg\"\n                                  alt=\"\"\n                                  className=\"object-contain\"\n                                  sizes=\"28px\"\n                                />\n                              )}\n                            </div>\n\n                            <span className=\"truncate text-sm\">\n                              {p.file.name}\n                            </span>\n\n                            {/* remove button (hover) */}\n                            <div\n                              className=\"absolute top-1/2 right-2 hidden size-5 -translate-y-1/2 cursor-pointer place-items-center bg-white group-hover:grid\"\n                              onClick={() => onFileRemove?.(p.file)}\n                            >\n                              <Icon\n                                path={mdiClose}\n                                className=\"text-blackAlpha-500 hover:text-blackAlpha-700\"\n                                size={\"2xs\"}\n                              />\n                            </div>\n                          </div>\n                        )\n                      })}\n                    </PopoverContent>\n                  </Popover>\n                )}\n              </div>\n            </div>\n\n            <div className=\"flex\">\n              <div className=\"flex items-center gap-1\">\n                <Button\n                  size={\"icon\"}\n                  variant=\"ghost\"\n                  colorScheme=\"neutral\"\n                  onClick={() => handleFileUpload()}\n                >\n                  <Icon path={mdiPaperclip} />\n                </Button>\n                {uploadedFiles && uploadedFiles.length > 0 && (\n                  <span\n                    className={cn(\n                      \"rounded px-1 py-0.5 text-xs\",\n                      uploadedFiles.length >= 8\n                        ? \"bg-orange-100 text-orange-600\"\n                        : \"text-gray-500\",\n                      uploadedFiles.length >= 10\n                        ? \"bg-red-100 text-red-600\"\n                        : \"\"\n                    )}\n                  >\n                    {uploadedFiles.length}/10\n                  </span>\n                )}\n              </div>\n\n              {isLoading || isChatActionPending ? (\n                <Button\n                  data-testid=\"prompt_form_stop_button\"\n                  size=\"icon\"\n                  variant=\"outline\"\n                  colorScheme=\"neutral\"\n                  className=\"text-neutral-fg text-md sm:border-color h-10 w-auto gap-2 rounded-3xl border-transparent p-2 font-semibold sm:px-4\"\n                  onClick={onStopGeneration}\n                >\n                  <span className=\"hidden sm:block\">Stop</span>\n                  <Icon\n                    path={mdiStop}\n                    className=\"neutral-fg text-primary-500 sm:hidden\"\n                  />\n                  <Icon\n                    path={mdiStopCircleOutline}\n                    className=\"neutral-fg hidden sm:block\"\n                  />\n                </Button>\n              ) : (\n                <Button\n                  data-testid=\"prompt_form_submit_button\"\n                  ref={btnRef}\n                  disabled={\n                    !isBrandkitIdAvailable ||\n                    input.trim().length === 0 ||\n                    isLoading ||\n                    isProcessingAllChanges ||\n                    Object.values(isProcessing).some((v) => v) ||\n                    isBrandkitDelete\n                  }\n                  type=\"submit\"\n                  variant=\"ghost\"\n                  colorScheme=\"neutral\"\n                  size=\"icon\"\n                  className=\"h-10 w-10 rounded-full\"\n                >\n                  <Icon path={mdiSend} aiGradient=\"600\" />\n                  <span className=\"sr-only\">Chat with your brand</span>\n                </Button>\n              )}\n            </div>\n          </div>\n        </div>\n      </div>\n      <p className=\"text-blackAlpha-300 text-center text-sm font-semibold\">\n        {config?.disclaimer\n          ? config?.disclaimer\n          : \"Stream AI can make mistakes. Check important info.\"}\n      </p>\n    </form>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/PromptForm.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/SourceItem.tsx",
      "content": "import React from \"react\"\nimport { mdiArrowRight, mdiLinkVariant } from \"@mdi/js\"\nimport { uniqueId } from \"lodash\"\n\nimport { cn } from \"../../lib/utils\"\nimport { StreamIcon } from \"../../ui/stream-icon\"\nimport { GetDocumentProxyUrl } from \"./GetDocumentProxyUrl\"\nimport { type Source } from \"./types\"\n\ninterface SourceItemProps {\n  index?: number\n  sources: [string, Source[]]\n}\n\nexport function SourceItem({ sources }: SourceItemProps): React.ReactNode {\n  const [toolTitle, _sources] = sources\n\n  /* Computed */\n  const contentTestId = toolTitle.split(\" \").join(\"_\").toLowerCase()\n\n  return (\n    <div className=\"mb-6 flex flex-col\">\n      <h4\n        className=\"text-blackAlpha-900 text-xl font-semibold\"\n        data-testid={`all_sources_${contentTestId}`}\n      >\n        {toolTitle}\n      </h4>\n      {_sources.map((source: Source, index: number) => {\n        const {\n          name = \"\",\n          description = \"\",\n          url = \"\",\n          title = \"\",\n          snippet = \"\",\n        } = source\n\n        return (\n          <div key={`source_item_${uniqueId()}`}>\n            <GetDocumentProxyUrl\n              url={url}\n              item={(url) => {\n                return (\n                  <a\n                    href={url}\n                    className=\"bg-subtle-bg my-1 flex cursor-pointer flex-col space-y-2 rounded-lg p-3\"\n                    target=\"_blank\"\n                    rel=\"noopener noreferrer\"\n                    data-testid={`all_sources_source_item_${contentTestId}_${index}`}\n                  >\n                    <header className=\"flex items-center text-lg font-semibold text-black\">\n                      {toolTitle === \"Web sources\" && (\n                        <StreamIcon path={mdiLinkVariant} />\n                      )}\n                      <span\n                        className={cn(\n                          \"\",\n                          toolTitle === \"Web sources\" && \"ml-2\"\n                        )}\n                      >\n                        {name || title || \"\"}\n                      </span>\n                    </header>\n                    <div className=\"text-md text-blackAlpha-900 font-normal\">\n                      {description || snippet || \"\"}\n                    </div>\n                    <footer className=\"flex justify-end\">\n                      <StreamIcon path={mdiArrowRight} />\n                    </footer>\n                  </a>\n                )\n              }}\n            />\n          </div>\n        )\n      })}\n    </div>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/SourceItem.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/Spinner.tsx",
      "content": "import React from \"react\"\n\nfunction mergeClasses(...classes: (string | undefined)[]): string {\n  return classes.filter(Boolean).join(\" \")\n}\n\ninterface SpinnerProps extends React.HTMLAttributes<HTMLDivElement> {\n  size?: \"xs\" | \"sm\" | \"md\" | \"lg\" | \"xl\"\n  message?: string\n  withOverlay?: boolean\n  fullscreen?: boolean\n}\n\nconst sizeClasses = {\n  xs: \"w-3 h-3\",\n  sm: \"w-4 h-4\",\n  md: \"w-6 h-6\",\n  lg: \"w-8 h-8\",\n  xl: \"w-12 h-12\",\n}\n\nfunction Spinner({\n  size = \"md\",\n  className,\n  message,\n  withOverlay = false,\n  fullscreen = false,\n  ...props\n}: SpinnerProps): React.ReactNode {\n  const spinnerClasses = mergeClasses(\n    \"inline-block rounded-full animate-spin border-4\",\n    \"border-t-purple-600 border-r-purple-600 border-b-gray-200 border-l-gray-200\",\n    sizeClasses[size],\n    className\n  )\n\n  const SpinnerElement = (\n    <div className=\"text-center\">\n      <div className={spinnerClasses} data-testid=\"spinner\" {...props} />\n      {message && <p className=\"mt-6 text-sm text-gray-600\">{message}</p>}\n    </div>\n  )\n\n  if (fullscreen) {\n    return (\n      <div className=\"fixed inset-0 z-50 flex items-center justify-center bg-white/90\">\n        {SpinnerElement}\n      </div>\n    )\n  }\n\n  if (withOverlay) {\n    return (\n      <div className=\"flex h-full w-full items-center justify-center bg-white/90\">\n        {SpinnerElement}\n      </div>\n    )\n  }\n\n  return SpinnerElement\n}\n\nexport { Spinner, type SpinnerProps }\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/Spinner.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/stream-messages.tsx",
      "content": "\"use client\"\n\nimport React, {\n  createContext,\n  useCallback,\n  useEffect,\n  useMemo,\n  type JSX,\n} from \"react\"\nimport { type UIMessage } from \"@ai-sdk/ui-utils\"\nimport { useChat, type UseChatHelpers } from \"ai/react\"\nimport {\n  Provider as JotaiProvider,\n  useAtom,\n  useAtomValue,\n  useSetAtom,\n} from \"jotai\"\nimport { toast } from \"sonner\"\n\nimport { useChatProvider } from \"./hooks/useChatProvider\"\nimport { Messages } from \"./Messages\"\nimport {\n  apiQueueAtom,\n  artifactsAtom,\n  brandkitIdAtom,\n  chatIdAtom,\n  configAtom,\n  hasErrorAtom,\n  isChatActionPendingAtom,\n  isLoadingAtom,\n  isNewChatAtom,\n  messagesIdsAtom,\n  postChatGenerateBodyAtom,\n  selectedChatWithIdAtom,\n} from \"./store/atoms\"\nimport { TOOL_ACTIONS, useToolDispatch } from \"./store/tools\"\nimport { type Session } from \"./store/types\"\nimport {\n  type MessageAnnotation,\n  type ResetSelections,\n  type SelectionValues,\n} from \"./types\"\nimport { useStreamMessagesClientsConfig } from \"./utils\"\n\nimport \"../../stream.css\"\n\nimport {\n  chat as chatApi,\n  dbMessagesToAIMessages,\n  HTTPError,\n  type ListUserChatMessagesModelResponseV2,\n} from \"@sitecore/stream-ui-core\"\nimport { type Message } from \"ai\"\nimport { last } from \"lodash\"\n\nimport { useGetChatMessages } from \"../../hooks/use-get-chat-messages\"\nimport { type Artifacts } from \"./store/types\"\n\nexport type ChatContextType = {\n  session: Session\n}\n\nexport type VercelAiUiProviderType = UseChatHelpers & {\n  brandkitId: string\n  chatId: string\n  addToolResult: ({\n    toolCallId,\n    result,\n  }: {\n    toolCallId: string\n    result: unknown\n  }) => void\n  rollbackChatChanges: (callbacks?: {\n    onRemoveChat?: () => void\n    onDeleteMessage?: () => void\n  }) => void\n  reset: (selections: ResetSelections) => void\n}\n\nexport const ChatContext = createContext<ChatContextType | undefined>(undefined)\nexport const VercelAiUiContext = createContext<\n  VercelAiUiProviderType | undefined\n>(undefined)\n\nconst baseUrlEnv = {\n  dev: \"-dev.sitecore-staging.cloud\",\n  qa: \"-qa.sitecore-staging.cloud\",\n  staging: \"-staging.sitecore-staging.cloud\",\n  preprod: \"-preprod.sitecorecloud.io\",\n  prod: \"sitecorecloud.io\",\n}\n\n/**\n * Configuration for example prompts displayed in the chat interface.\n */\ntype ExamplePrompt = {\n  /**\n   * Icon element to display alongside the prompt.\n   * @example <span className=\"text-md neutral-fg ml-auto\">ðŸ’¡</span>\n   */\n  icon: JSX.Element\n\n  /**\n   * The text content of the example prompt.\n   * @example \"Generate a creative brief for a new product launch\"\n   */\n  content: string\n}\n\nexport interface ChatProps {\n  session: Omit<Session, \"apiEnv\">\n  children?: React.ReactNode\n}\n\n/**\n * Props for the StreamMessages component.\n */\nexport interface StreamMessagesProps {\n  brandkitId: string\n  chatId: string\n  isNewChat: boolean\n  onStream?: (data: {\n    isStreaming: boolean\n    finished: boolean\n    message: Message | null\n  }) => void\n  /**\n   * Initial prompt to display in the chat interface.\n   * @example \"Generate a creative brief for a new product launch\"\n   * @default undefined\n   */\n  prompt?: string\n\n  /**\n   * Configuration options for customizing the chat interface.\n   * @default undefined\n   */\n  config?: {\n    /**\n     * Disclaimer text or component to display in the chat interface.\n     * @example \"This is a test disclaimer. It can be a string or a React node.\"\n     * @example <div className=\"text-sm text-neutral-500\"><p>AI responses may contain errors.</p></div>\n     * @default undefined\n     */\n    disclaimer?: string | React.ReactNode\n\n    /**\n     * Array of example prompts to show users before they start chatting.\n     * @example [\n     *   {\n     *     icon: <span className=\"text-md neutral-fg ml-auto\">ðŸ’¡</span>,\n     *     content: 'Generate a creative brief for a new product launch'\n     *   },\n     *   {\n     *     icon: <span className=\"text-md neutral-fg ml-auto\">ðŸ§ </span>,\n     *     content: 'Brainstorm some ideas for a social media campaign'\n     *   }\n     * ]\n     * @default undefined\n     */\n    examplePrompts?: ExamplePrompt[]\n  }\n}\n\nexport function Chat({ session, children }: ChatProps) {\n  const apiEnv = `${session.region}${baseUrlEnv[session.env]}`\n\n  return (\n    <ChatContext.Provider value={{ session: { ...session, apiEnv } }}>\n      <JotaiProvider>{children}</JotaiProvider>\n    </ChatContext.Provider>\n  )\n}\n\n/**\n * StreamMessages is a React component that provides a chat interface with AI capabilities.\n * It handles real-time messaging, tool invocations, and integrates with various AI services\n * for brainstorming, content generation, and more.\n *\n * @param props - The props for the StreamMessages component\n * @returns A JSX element rendering the complete chat interface\n *\n * @example\n * ```tsx\n * // Basic usage with required session configuration\n * <StreamMessages\n *   session={{\n *     brandkitId: '2f669d68-d5ab-4664-944a-b1504a1a2a6c',\n *     userId: 'auth0|1234567890',\n *     orgId: 'org_b07iKFjB2zYhi49p',\n *     chatId: 'e092c859-fce8-49be-b916-bf84477659d8',\n *     region: 'euw',\n *     env: 'dev',\n *     token: 'your-auth-token-here'\n *   }}\n * />\n *\n * // Advanced usage with custom configuration and example prompts\n * <StreamMessages\n *   session={{\n *     brandkitId: '2f669d68-d5ab-4664-944a-b1504a1a2a6c',\n *     userId: 'auth0|1234567890',\n *     orgId: 'org_b07iKFjB2zYhi49p',\n *     chatId: 'e092c859-fce8-49be-b916-bf84477659d8',\n *     region: 'euw',\n *     env: 'dev',\n *     token: 'your-auth-token-here'\n *   }}\n *   prompt=\"Generate a creative brief for a new product launch\"\n *   config={{\n *     examplePrompts: [\n *       {\n *         icon: <span className=\"text-md neutral-fg ml-auto\">ðŸ’¡</span>,\n *         content: 'Generate a creative brief for a new product launch',\n *       },\n *       {\n *         icon: <span className=\"text-md neutral-fg ml-auto\">ðŸ§ </span>,\n *         content: 'Brainstorm some ideas for a social media campaign',\n *       },\n *     ],\n *     disclaimer: (\n *       <div className=\"text-sm text-neutral-500\">\n *         <p>This is a test disclaimer. It can be a string or a React node.</p>\n *       </div>\n *     ),\n *   }}\n * />\n * ```\n *\n * @remarks\n * This component requires the stream clients to be loaded via `useStreamMessagesClientsConfig`\n * before it can function properly. It manages chat state through Jotai atoms and integrates\n * with the Vercel AI SDK for chat functionality.\n */\nfunction StreamMessages({\n  brandkitId,\n  chatId,\n  prompt,\n  config,\n  isNewChat,\n  onStream,\n}: StreamMessagesProps): JSX.Element {\n  /* Atoms */\n  const chatBodyAtom = useAtomValue(postChatGenerateBodyAtom)\n  const setMessageIds = useSetAtom(messagesIdsAtom)\n  const [isLoading, setIsLoading] = useAtom(isLoadingAtom)\n  const [, dispatchToolAction] = useToolDispatch()\n  const setConfig = useSetAtom(configAtom)\n\n  /* Hooks */\n  const { session } = useChatProvider()\n  const getChatMessages = useGetChatMessages(session.orgId, session.userId)\n  const setApiQueue = useSetAtom(apiQueueAtom)\n  const setArtifacts = useSetAtom(artifactsAtom)\n  const setSelectedChatWithId = useSetAtom(selectedChatWithIdAtom)\n  const setIsChatActionPending = useSetAtom(isChatActionPendingAtom)\n  const setHasError = useSetAtom(hasErrorAtom)\n  const [_isNewChat, setIsNewChat] = useAtom(isNewChatAtom)\n  const [_chatId, setChatId] = useAtom(chatIdAtom)\n  const setBrandkitId = useSetAtom(brandkitIdAtom)\n\n  const {\n    isLoading: _isLoading,\n    messages,\n    setMessages,\n    setInput,\n    stop,\n    ...chat\n  } = useChat({\n    api: `https://ai-chat-api-${session.region}${baseUrlEnv[session.env]}/api/chats/v1/organizations/${session.orgId}/users/${session.userId}/chats/${_chatId}/generatemessage`,\n    body: chatBodyAtom,\n    initialInput: prompt ?? \"\",\n    headers: {\n      Authorization: `Bearer ${session.token}`,\n      \"Content-Type\": \"application/json\",\n    },\n    experimental_throttle: 200,\n    onResponse: () => {\n      onStream?.({ isStreaming: true, finished: false, message: null })\n    },\n    onFinish: async (message) => {\n      const messageId = (\n        message?.annotations?.[0] as unknown as MessageAnnotation\n      )?.id\n      setMessageIds((prev) => [...prev, messageId])\n\n      onStream?.({ isStreaming: false, finished: true, message: message })\n    },\n    onError: (error) => {\n      console.error(\"Error:\", error)\n      onStream?.({ isStreaming: false, finished: true, message: null })\n    },\n  })\n\n  /* Computed */\n  const areMessagesAvailable = !!messages?.length\n\n  const reset = useCallback(\n    (selections: ResetSelections) => {\n      const actions = {\n        messages: (value?: Message[]) => {\n          setMessages(value ?? [])\n          setMessageIds([])\n          setSelectedChatWithId(\"\")\n        },\n        artifacts: (value?: Artifacts) => setArtifacts(value ?? {}),\n        isChatActionPending: (value?: boolean) =>\n          setIsChatActionPending(value ?? false),\n        hasError: (value?: boolean) => setHasError(value ?? false),\n        input: (value?: string) => setInput(value ?? \"\"),\n      }\n\n      selections.forEach((selection) => {\n        if (Array.isArray(selection)) {\n          const [key, value] = selection as SelectionValues\n          actions[key](value as never)\n        } else actions[selection]()\n      })\n    },\n    [\n      setArtifacts,\n      setHasError,\n      setInput,\n      setIsChatActionPending,\n      setMessageIds,\n      setMessages,\n      setSelectedChatWithId,\n    ]\n  )\n\n  const initMessages = useCallback(async (): Promise<void> => {\n    /* Get messages for a specific chat */\n    const messages: ListUserChatMessagesModelResponseV2[] =\n      await getChatMessages(_chatId)\n    const dbMessages = dbMessagesToAIMessages(messages) as UIMessage[]\n\n    setMessages(dbMessages)\n    setMessageIds(\n      dbMessages.map((message) => {\n        return (message?.annotations?.[0] as unknown as MessageAnnotation)?.id\n      })\n    )\n  }, [getChatMessages, _chatId, setMessageIds, setMessages])\n\n  const rollbackChatChanges = useCallback(\n    async (callbacks?: {\n      onRemoveChat?: () => void\n      onDeleteMessage?: () => void\n    }) => {\n      const { onRemoveChat, onDeleteMessage } = callbacks ?? {}\n\n      const messageAssistant = (last(messages) as Message)?.role === \"assistant\"\n      const messageId = (\n        (last(messages) as Message)\n          ?.annotations?.[0] as unknown as MessageAnnotation\n      )?.id\n\n      const isMessageAssistantInvalid = !messageAssistant || !messageId\n      const isFirstMessage = messages.length && messages.length <= 2\n\n      stop()\n      onStream?.({ isStreaming: false, finished: true, message: null })\n\n      queueMicrotask(() => {\n        setApiQueue({})\n        reset([\"hasError\", \"artifacts\"])\n      })\n\n      /* If there are two or fewer messages, then delete the chat */\n      if (isFirstMessage) {\n        try {\n          await chatApi.deleteUserChatApiChatsV1OrganizationsOrganizationIdUsersUserIdChatsChatIdDelete(\n            {\n              path: {\n                userId: session.userId,\n                chatId: _chatId,\n                organizationId: session.orgId,\n              },\n            }\n          )\n          await initMessages()\n\n          if (onRemoveChat) {\n            onRemoveChat()\n            return\n          }\n        } catch (error: unknown) {\n          const { response } = error as HTTPError\n          const { detail } = (await response.json()) as {\n            type: string\n            detail: string\n          }\n          toast.error(detail)\n        } finally {\n          queueMicrotask(() => {\n            setChatId(\"\")\n            setApiQueue({})\n            reset([\n              \"hasError\",\n              \"artifacts\",\n              \"isChatActionPending\",\n              \"input\",\n              \"messages\",\n              \"artifacts\",\n            ])\n          })\n        }\n        return\n      }\n\n      if (isMessageAssistantInvalid) {\n        if (onDeleteMessage) {\n          onDeleteMessage()\n          return\n        }\n        await initMessages()\n        return\n      }\n\n      try {\n        await chatApi.deleteUserChatMessageApiChatsV1OrganizationsOrganizationIdUsersUserIdChatsChatIdMessagesMessageIdDelete(\n          {\n            path: {\n              userId: session.userId,\n              chatId: _chatId,\n              organizationId: session.orgId,\n              messageId,\n            },\n          }\n        )\n        if (onDeleteMessage) {\n          onDeleteMessage()\n          return\n        }\n      } catch (error: unknown) {\n        const { response } = error as HTTPError\n        const { detail } = (await response.json()) as {\n          type: string\n          detail: string\n        }\n        toast.error(detail)\n      }\n    },\n    [\n      messages,\n      stop,\n      setChatId,\n      setApiQueue,\n      reset,\n      session.userId,\n      session.orgId,\n      _chatId,\n      initMessages,\n    ]\n  )\n\n  const handleNewChat = useCallback(() => {\n    setIsNewChat(false)\n    dispatchToolAction({ type: TOOL_ACTIONS.RESET_ALL_TOOLS })\n    setArtifacts({})\n    setMessages([])\n    setChatId(\"\")\n\n    if (isLoading) {\n      rollbackChatChanges({\n        onDeleteMessage: () => {\n          setMessages([])\n        },\n      })\n    }\n  }, [\n    dispatchToolAction,\n    isLoading,\n    rollbackChatChanges,\n    setArtifacts,\n    setChatId,\n    setIsNewChat,\n    setMessages,\n  ])\n\n  const updateInternalState = useCallback(() => {\n    if (chatId) setChatId(chatId)\n    if (brandkitId) setBrandkitId(brandkitId)\n    if (isNewChat) {\n      setIsNewChat(isNewChat)\n      handleNewChat()\n    }\n    if (config) setConfig(config)\n    if (_isLoading !== isLoading) {\n      setIsLoading(_isLoading)\n    }\n  }, [\n    _isLoading,\n    brandkitId,\n    chatId,\n    config,\n    handleNewChat,\n    isLoading,\n    isNewChat,\n    setBrandkitId,\n    setChatId,\n    setConfig,\n    setIsLoading,\n    setIsNewChat,\n  ])\n\n  const handleChatInit = useCallback(() => {\n    if (!_chatId) return\n\n    if (_isNewChat) {\n      setIsNewChat(false)\n      chat.handleSubmit()\n      return\n    }\n\n    if (!areMessagesAvailable) {\n      initMessages()\n    }\n  }, [\n    _chatId,\n    _isNewChat,\n    areMessagesAvailable,\n    chat,\n    initMessages,\n    setIsNewChat,\n  ])\n\n  useEffect(() => {\n    updateInternalState()\n    handleChatInit()\n  }, [handleChatInit, updateInternalState])\n\n  const context = useMemo(\n    () => ({\n      ...chat,\n      setInput,\n      reset,\n      rollbackChatChanges,\n      setMessages,\n      messages,\n      isLoading,\n      stop,\n      brandkitId,\n      chatId,\n    }),\n    [\n      brandkitId,\n      chat,\n      chatId,\n      isLoading,\n      messages,\n      reset,\n      rollbackChatChanges,\n      setInput,\n      setMessages,\n      stop,\n    ]\n  )\n\n  return (\n    <VercelAiUiContext.Provider value={context}>\n      <Messages />\n    </VercelAiUiContext.Provider>\n  )\n}\n\nexport { StreamMessages, useStreamMessagesClientsConfig }\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/stream-messages.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/ActionModal.tsx",
      "content": "import React, { useState, type MouseEvent } from \"react\"\nimport { upperFirst } from \"lodash\"\n\nimport { Button } from \"@/registry/new-york/ui/button\"\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \"@/registry/new-york/ui/dialog\"\n\nimport { cn } from \"../../lib/utils\"\n\nexport type ActionModalProps = {\n  ctaElement?: React.ReactNode\n  dialogClassName?: string\n  ctaTitle?: string\n  ctaClassName?: string\n  modalTitle?: string\n  contentClassName?: string\n  children?: React.ReactNode | React.ReactNode[]\n  footerContent?: React.ReactNode | React.ReactNode[]\n  interactiveOutside?: boolean\n  \"data-testid\"?: string\n} & (\n  | {\n      isOpen: boolean\n      onOpenChange: (open: boolean) => void\n    }\n  | {\n      isOpen?: undefined\n      onOpenChange?: undefined\n    }\n)\n\nexport function ActionModal({\n  children,\n  ctaElement,\n  dialogClassName,\n  ctaTitle = \"Action\",\n  ctaClassName = \"\",\n  modalTitle = \"Modal\",\n  contentClassName = \"\",\n  footerContent,\n  interactiveOutside = true,\n  isOpen,\n  onOpenChange,\n  \"data-testid\": dataTestId,\n  ...otherProps\n}: ActionModalProps) {\n  const [open, setOpen] = useState(false)\n\n  const handleOnInteractiveOutside = (e: Event) => {\n    e.preventDefault()\n  }\n\n  const handleOpenModalOnAction = (e: MouseEvent) => {\n    e.preventDefault()\n    setOpen(true)\n  }\n\n  const dialogTestId = dataTestId || `action_modal_${ctaTitle?.toLowerCase()}`\n  const ctaTitleTestId = ctaTitle?.toLowerCase()\n\n  return (\n    <Dialog\n      open={isOpen === undefined ? open : isOpen}\n      onOpenChange={\n        onOpenChange === undefined ? () => setOpen(false) : onOpenChange\n      }\n      {...otherProps}\n    >\n      <DialogTrigger asChild>\n        {ctaElement ? (\n          <div\n            data-testid={`action_modal_button_${ctaTitleTestId}`}\n            className=\"m-0 border-none bg-none p-0\"\n          >\n            {ctaElement}\n          </div>\n        ) : (\n          <Button\n            variant=\"ghost\"\n            className={cn(\n              \"text-neutral-fg text-md px-2 py-0 font-semibold hover:bg-transparent active:bg-transparent\",\n              ctaClassName\n            )}\n            data-testid={`action_modal_button_${ctaTitleTestId}`}\n            onClick={handleOpenModalOnAction}\n          >\n            {ctaTitle}\n          </Button>\n        )}\n      </DialogTrigger>\n      <DialogContent\n        className={cn(\"max-w-2xl p-4\", dialogClassName)}\n        onInteractOutside={\n          interactiveOutside ? undefined : handleOnInteractiveOutside\n        }\n        data-testid={dialogTestId}\n      >\n        <DialogHeader>\n          <DialogTitle\n            data-testid={`action_modal_header_${ctaTitleTestId}`}\n            className=\"body-text text-xl\"\n          >\n            {upperFirst(modalTitle)}\n          </DialogTitle>\n          <DialogDescription className=\"sr-only\">\n            {upperFirst(modalTitle)} dialog content\n          </DialogDescription>\n        </DialogHeader>\n        <div\n          data-testid={`action_modal_content_${ctaTitleTestId}`}\n          className={cn(\"max-h-[650px] overflow-y-auto\", contentClassName)}\n        >\n          {children}\n        </div>\n        <DialogFooter>{footerContent}</DialogFooter>\n      </DialogContent>\n    </Dialog>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/ActionModal.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/UserMessage.tsx",
      "content": "import React, { useState } from \"react\"\n\nimport EditCommands from \"./EditCommands\"\n\nexport interface UserMessageProps {\n  children?: React.ReactNode | React.ReactNode[] | string\n}\n\nexport function UserMessage({ children }: UserMessageProps): React.ReactNode {\n  const [showCommands, setShowCommands] = useState<boolean>(false)\n\n  return (\n    <div\n      data-testid=\"user_message\"\n      className=\"group relative flex items-center justify-start\"\n      onMouseOver={() => setShowCommands(true)}\n      onMouseOut={() => setShowCommands(false)}\n    >\n      <div className=\"text-body-text relative z-10 overflow-hidden text-3xl font-semibold break-words whitespace-pre-line\">\n        {children}\n      </div>\n      {showCommands && (\n        <EditCommands>\n          <EditCommands.Copy\n            className=\"h-9 w-9\"\n            iconClassname=\"text-blackAlpha-400 text-2xs\"\n            text={children as string}\n          />\n        </EditCommands>\n      )}\n    </div>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/UserMessage.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/EditCommands.tsx",
      "content": "import React from \"react\"\nimport { mdiContentCopy } from \"@mdi/js\"\n\nimport { Button } from \"@/registry/new-york/ui/button\"\n\nimport { cn } from \"../../lib/utils\"\nimport { StreamIcon } from \"../../ui/stream-icon\"\nimport { copyToClipboard } from \"./utils\"\n\ninterface EditCommandsProps {\n  children: React.ReactNode\n  className?: string\n}\n\ntype CopyCommandProps = { className?: string; iconClassname?: string } & (\n  | { text: string; onClick?: never }\n  | { text?: never; onClick: () => void }\n  | { text?: never; onClick?: never }\n)\n\nfunction CopyCommand({\n  className,\n  iconClassname,\n  text,\n  onClick,\n}: CopyCommandProps): React.ReactNode {\n  const handleCopyToClipboardOnClick = (): void => {\n    if (onClick) {\n      onClick()\n      return\n    }\n    if (text) copyToClipboard(text)\n  }\n\n  return (\n    <>\n      <Button\n        data-testid=\"edit_commands_copy\"\n        className={cn(\"\", className)}\n        size=\"icon\"\n        variant=\"ghost\"\n        colorScheme=\"neutral\"\n        onClick={handleCopyToClipboardOnClick}\n      >\n        <StreamIcon className={cn(\"\", iconClassname)} path={mdiContentCopy} />\n      </Button>\n    </>\n  )\n}\n\nfunction EditCommands({\n  children,\n  className,\n}: EditCommandsProps): React.ReactNode {\n  return (\n    <div\n      data-testid=\"edit_commands_container\"\n      className={cn(\"flex justify-between\", className)}\n    >\n      {children}\n    </div>\n  )\n}\n\nEditCommands.Copy = CopyCommand\n\nexport default EditCommands\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/EditCommands.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/GetDocumentProxyUrl.tsx",
      "content": "import { useCallback, useEffect, useRef, useState } from \"react\"\n\nimport { useChatProvider } from \"../chat/hooks/useChatProvider\"\n\nexport interface GetDocumentProxyUrlProps {\n  url: string\n  item: (url: string) => React.ReactNode\n}\n\nexport function GetDocumentProxyUrl({ url, item }: GetDocumentProxyUrlProps) {\n  /* Atoms */\n  const { session } = useChatProvider()\n\n  /* Hooks */\n  const [objectUrl, setObjectUrl] = useState<string | undefined>(undefined)\n  const currentObjectUrlRef = useRef<string | undefined>(undefined)\n\n  const getDocumentProxyUrl = useCallback(\n    async (url: string): Promise<string | undefined> => {\n      // Clean up previous object URL\n      if (currentObjectUrlRef.current) {\n        URL.revokeObjectURL(currentObjectUrlRef.current)\n        currentObjectUrlRef.current = undefined\n      }\n\n      // If URL is falsy, clear the state and return\n      if (!url) {\n        setObjectUrl(undefined)\n        return undefined\n      }\n\n      if (!url.startsWith(\"https://mms-delivery\")) return url\n\n      try {\n        const res = await fetch(url, {\n          headers: {\n            Authorization: `Bearer ${session?.token}`,\n          },\n        })\n\n        if (!res.ok) {\n          setObjectUrl(undefined)\n          return undefined\n        }\n\n        const newObjectUrl = URL.createObjectURL(await res.blob())\n        currentObjectUrlRef.current = newObjectUrl\n        setObjectUrl(newObjectUrl)\n      } catch (error) {\n        setObjectUrl(undefined)\n        return undefined\n      }\n    },\n    [session?.token]\n  )\n\n  const renderItem = () => item(objectUrl || url)\n\n  useEffect(() => {\n    if (session?.token || !url) {\n      getDocumentProxyUrl(url)\n    }\n  }, [getDocumentProxyUrl, session?.token, url])\n\n  useEffect(() => {\n    return () => {\n      if (currentObjectUrlRef.current) {\n        URL.revokeObjectURL(currentObjectUrlRef.current)\n      }\n    }\n  }, [])\n\n  return <>{renderItem()}</>\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/GetDocumentProxyUrl.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/Feedback.tsx",
      "content": "import React, { useEffect, useState } from \"react\"\nimport { type UIMessage } from \"@ai-sdk/ui-utils\"\nimport { mdiWeb } from \"@mdi/js\"\nimport {\n  type ContentModelRead,\n  type ListUserChatMessagesModelResponseV2,\n} from \"@sitecore/stream-ui-core\"\nimport { useSetAtom } from \"jotai\"\n\nimport { Button } from \"@/registry/new-york/ui/button\"\n\nimport { Icon } from \"../chat/Icon\"\nimport { postChatGenerateBodyAtom } from \"../chat/store/atoms\"\nimport { useAiChatProvider } from \"./hooks/useAiChatProvider\"\nimport { useChatProvider } from \"./hooks/useChatProvider\"\nimport { MessageFeedback } from \"./MessageFeedback\"\nimport { type MessageAnnotation } from \"./types\"\nimport { ReferencesBuilder } from \"./utils/referencesBuilder\"\n\nexport interface FeedbackProps {\n  message: UIMessage &\n    Pick<ListUserChatMessagesModelResponseV2, \"feedback\"> & {\n      content?: string | Array<ContentModelRead>\n    }\n  isLastMessage: boolean\n  previousMessageContent?: string\n  messageId: string\n}\n\nexport const SEARCH_THE_WEB_TEXT = \"Search the web for:\"\n\nexport function Feedback({\n  messageId,\n  message,\n  previousMessageContent,\n  isLastMessage,\n}: FeedbackProps): React.ReactNode {\n  /* Hooks */\n  const { session } = useChatProvider()\n  const { setInput, handleSubmit, input, brandkitId } = useAiChatProvider()\n  const [searchWeb, setSearchWeb] = useState(false)\n\n  /* Atoms */\n  const setChatBodyAtom = useSetAtom(postChatGenerateBodyAtom)\n\n  /* Computed */\n  const messageAnnotation = message\n    ?.annotations?.[0] as unknown as MessageAnnotation\n  const isMessageFeedbackAvailable = !!messageAnnotation?.id?.length\n  const isWebSearchToolAvailable = !!message?.parts?.filter(\n    (part) =>\n      part.type === \"tool-invocation\" &&\n      part.toolInvocation.toolName === \"web_search\"\n  ).length\n\n  useEffect(() => {\n    if (input && searchWeb) {\n      setSearchWeb(false)\n      handleSubmit()\n    }\n  }, [handleSubmit, input, searchWeb])\n\n  const handleWebSearchOnClick = () => {\n    const hasSearchMessage =\n      previousMessageContent?.includes(SEARCH_THE_WEB_TEXT)\n    const prompt =\n      `${hasSearchMessage ? \"\" : SEARCH_THE_WEB_TEXT} ${previousMessageContent}`.trim()\n\n    const data = {\n      content: prompt,\n      references: [\n        ...ReferencesBuilder({ orgId: session.orgId, userId: session.userId })\n          .addBrandkit({ id: brandkitId, isArtefact: false })\n          .build(),\n      ],\n      mode: \"web_search\",\n    }\n\n    setChatBodyAtom(data)\n    setInput(prompt)\n    setSearchWeb(true)\n  }\n\n  return (\n    <div className=\"flex w-full items-center rounded-lg py-2\">\n      {isMessageFeedbackAvailable && (\n        <>\n          <MessageFeedback messageId={messageId} message={message} />\n          {isLastMessage && !isWebSearchToolAvailable && (\n            <Button\n              data-testid=\"search_the_web_button\"\n              variant=\"ghost\"\n              colorScheme=\"neutral\"\n              onClick={handleWebSearchOnClick}\n            >\n              <Icon path={mdiWeb} /> <span>Search the web</span>\n            </Button>\n          )}\n        </>\n      )}\n    </div>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/Feedback.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/Workflow.tsx",
      "content": "import React from \"react\"\nimport { mdiCheck, mdiLoading, mdiStarFourPoints } from \"@mdi/js\"\nimport { isString } from \"lodash\"\n\nimport { cn } from \"../../lib/utils\"\nimport { StreamIcon } from \"../../ui/stream-icon\"\nimport { Markdown } from \"./Markdown\"\nimport type { Source } from \"./types\"\nimport { firstCharToUpperCase } from \"./utils\"\n\nexport type SearchContentProps = {\n  question: string\n} & {\n  knowledge_search: Source[]\n  brand_knowledge: Source[]\n  web_search: { result: string; sources: Source[] }[]\n}\n\nexport interface BrainstormingWorkflowSearch {\n  name: string\n  content: SearchContentProps[]\n}\n\nexport interface WorkflowBrandkitSection {\n  sectionName: string\n  sectionId: string\n  fields: string[]\n}\n\nexport interface WorkflowItem {\n  name: string\n  content: string | React.ReactNode | React.ReactNode[] | SearchContentProps[]\n  isLoading?: boolean\n  data?: {\n    brandkitSections: WorkflowBrandkitSection[]\n  }\n}\n\nexport interface WorkflowProps {\n  items: WorkflowItem[]\n}\n\nexport function Workflow({ items }: WorkflowProps): React.ReactNode {\n  if (!items.length) return null\n\n  return (\n    <div className=\"relative space-y-2 pl-6\" data-testid=\"thinking_workflow\">\n      {items.map((item, index) => {\n        const isComplete = !item.isLoading && item.content\n\n        return (\n          <div\n            key={index}\n            className=\"relative flex items-start gap-4 before:absolute before:top-8 before:bottom-0 before:left-3 before:w-[2px] before:bg-gray-200 before:content-[''] last:before:hidden\"\n          >\n            {/* Icon */}\n            <div className=\"relative z-10\">\n              <div\n                className={cn(\n                  \"flex h-6 w-6 items-center justify-center rounded-full border-2 bg-white\",\n                  {\n                    \"border-purple-500\": isComplete,\n                    \"border-gray-300\": !isComplete,\n                  }\n                )}\n              >\n                <StreamIcon\n                  path={\n                    item.isLoading\n                      ? mdiLoading\n                      : isComplete\n                        ? mdiCheck\n                        : mdiStarFourPoints\n                  }\n                  size=\"3xs\"\n                  className={cn(\"h-4 w-4 text-gray-500\", {\n                    \"animate-spin\": item.isLoading,\n                    \"text-purple-500\": isComplete,\n                  })}\n                />\n              </div>\n            </div>\n\n            {/* Content */}\n            <div className=\"min-h-20 flex-1\">\n              <h4 className=\"text-md text-blackAlpha-900 font-medium\">\n                {firstCharToUpperCase(item.name)}\n              </h4>\n              <div className=\"text-md text-blackAlpha-900 mt-1 font-normal\">\n                {isString(item.content) ? (\n                  <Markdown id=\"workflow\" text={item.content} />\n                ) : (\n                  (item.content as React.ReactNode | React.ReactNode[])\n                )}\n              </div>\n            </div>\n          </div>\n        )\n      })}\n    </div>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/Workflow.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/ButtonScrollToBottom.tsx",
      "content": "import React from \"react\"\nimport { mdiArrowDown } from \"@mdi/js\"\n\nimport { Button } from \"@/registry/new-york/ui/button\"\n\nimport { cn } from \"../../lib/utils\"\nimport { StreamIcon } from \"../../ui/stream-icon\"\n\ninterface ButtonScrollToBottomProps {\n  isAtBottom: boolean\n  scrollToBottom: () => void\n}\n\nexport function ButtonScrollToBottom({\n  isAtBottom,\n  scrollToBottom,\n  ...props\n}: ButtonScrollToBottomProps): React.ReactNode {\n  return (\n    <Button\n      variant=\"outline\"\n      colorScheme=\"neutral\"\n      size=\"icon\"\n      className={cn(\n        \"absolute top-[-4rem] right-16 z-10 bg-white shadow-lg transition-opacity hover:bg-gray-100\",\n        isAtBottom ? \"opacity-0\" : \"opacity-100\"\n      )}\n      onClick={() => scrollToBottom()}\n      {...props}\n    >\n      <StreamIcon path={mdiArrowDown} />\n      <span className=\"sr-only\">Scroll to bottom</span>\n    </Button>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/ButtonScrollToBottom.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/types.ts",
      "content": "import { type FunctionComponent } from \"react\"\nimport { type UIMessage } from \"@ai-sdk/ui-utils\"\nimport {\n  type ReferenceModel,\n  type ToolInvocation,\n} from \"@sitecore/stream-ui-core\"\nimport { type Message } from \"ai\"\n\nimport { type Artifacts } from \"../chat/store/types\"\nimport { TOOLS_SOURCES_TITLES } from \"./utils\"\n\nexport type ExtractSourceRecordProps = Record<\n  (typeof TOOLS_SOURCES_TITLES)[keyof typeof TOOLS_SOURCES_TITLES],\n  Source[]\n>\nexport type ExtractSourceProps = [\n  (typeof TOOLS_SOURCES_TITLES)[keyof typeof TOOLS_SOURCES_TITLES],\n  Source[],\n]\nexport type ExtractSourcesProps = ExtractSourceProps[]\n\nexport interface MessageContent {\n  type: \"text\"\n  tool: string\n  value: object\n}\n\nexport interface ToolProps {\n  id?: number | string\n  messageId: string\n  message: UIMessage\n  toolInvocation: ToolInvocationRefProps\n}\n\nexport type HTTPValidationError = {\n  detail: {\n    loc: string | number[]\n    msg: string\n    type: string\n  }[]\n}\n\nexport interface ToolInvocationsProps {\n  messageId: string\n  message: UIMessage\n  toolInvocations: ToolInvocationRefProps[]\n  isLastMessage: boolean\n}\n\nexport interface Source {\n  id: string\n  documentId: string\n  title: string\n  url: string\n  description: string\n  type: \"image\" | \"pdf\" | void\n  name: string\n  siteName: string\n  content: string\n  snippet: string\n}\n\nexport type ToolInvocationRefProps = ToolInvocation & {\n  reference: ReferenceModel\n}\n\nexport interface Tools {\n  [key: string]: FunctionComponent<ToolProps>\n}\n\nexport interface DbPart {\n  tool: string\n  value: Record<string, unknown>\n}\n\nexport interface MessageAnnotation {\n  id: string\n  references: Array<ReferenceModel>\n}\n\nexport interface MessageFeedback {\n  type?: \"good\" | \"bad\"\n  message?: string\n  reason?: string\n  categories?: string[]\n}\n\n// ListUserChatMessagesModelResponseV2\nexport interface DBMessage {\n  id: string\n  role: \"system\" | \"user\" | \"assistant\" | \"tool\"\n  content: unknown\n  references: Array<ReferenceModel>\n  timestamp: number\n  feedback?: MessageFeedback\n}\n\nexport type SelectionTypes =\n  | \"messages\"\n  | \"artifacts\"\n  | \"isChatActionPending\"\n  | \"hasError\"\n  | \"input\"\nexport type SelectionValues =\n  | [\"messages\", Message[]]\n  | [\"artifacts\", Artifacts]\n  | [\"isChatActionPending\", boolean]\n  | [\"hasError\", boolean]\n  | [\"input\", string]\nexport type Selections = SelectionTypes | SelectionValues\nexport type ResetSelections = Selections[]\n",
      "type": "registry:file",
      "target": "components/stream-components/blocks/chat/types.ts"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/hooks/useAutoScroll.tsx",
      "content": "import React, { useEffect, useRef, useState, type ReactNode } from \"react\"\n\nfunction useAutoScroll(content: ReactNode | ReactNode[]): {\n  contentRef: React.RefObject<HTMLDivElement>\n  handleStopAutoScrollingOnScroll: () => void\n} {\n  const contentRef = useRef<HTMLDivElement>({} as HTMLDivElement)\n  const [isUserScrolling, setIsUserScrolling] = useState<boolean>(false)\n\n  const handleStopAutoScrollingOnScroll = (): void => {\n    setIsUserScrolling(true)\n  }\n\n  useEffect(() => {\n    if (contentRef.current && !isUserScrolling) {\n      const scrollableElement = contentRef.current\n\n      if (scrollableElement.scrollHeight > scrollableElement.clientHeight) {\n        scrollableElement.scrollTop = scrollableElement.scrollHeight\n      }\n    }\n  }, [isUserScrolling, content])\n\n  return {\n    contentRef,\n    handleStopAutoScrollingOnScroll,\n  }\n}\n\nexport { useAutoScroll }\n",
      "type": "registry:hook",
      "target": "components/stream-components/blocks/chat/hooks/useAutoScroll.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/hooks/useEnterSubmit.tsx",
      "content": "import React, { useRef, type RefObject } from \"react\"\n\nexport function useEnterSubmit(): {\n  formRef: RefObject<HTMLFormElement>\n  onKeyDown: (event: React.KeyboardEvent<HTMLTextAreaElement>) => void\n} {\n  const formRef = useRef<HTMLFormElement>({} as HTMLFormElement)\n\n  const handleKeyDown = (\n    event: React.KeyboardEvent<HTMLTextAreaElement>\n  ): void => {\n    if (\n      event.key === \"Enter\" &&\n      !event.shiftKey &&\n      !event.nativeEvent.isComposing\n    ) {\n      formRef.current?.requestSubmit()\n      event.preventDefault()\n    }\n  }\n\n  return { formRef, onKeyDown: handleKeyDown }\n}\n",
      "type": "registry:hook",
      "target": "components/stream-components/blocks/chat/hooks/useEnterSubmit.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/hooks/useImageDropzone.tsx",
      "content": "import { useCallback, useMemo } from \"react\"\nimport {\n  useDropzone,\n  type DropzoneInputProps,\n  type DropzoneRootProps,\n} from \"react-dropzone\"\nimport { toast } from \"sonner\"\n\ntype UseImageDropzoneOptions = {\n  enabled: boolean\n  currentCount: number\n  maxTotal?: number // default 10\n  maxSizeBytes?: number // default 5MB\n  onFilesAccepted?: (files: File[]) => void\n}\n\ntype UseImageDropzoneResult = {\n  getRootProps: () => DropzoneRootProps\n  getInputProps: () => DropzoneInputProps\n  isDragActive: boolean\n  open: () => void\n  remainingSlots: number\n}\n\nexport function useImageDropzone(\n  options: UseImageDropzoneOptions\n): UseImageDropzoneResult {\n  const {\n    enabled,\n    currentCount,\n    maxTotal = 10,\n    maxSizeBytes = 5 * 1024 * 1024,\n    onFilesAccepted,\n  } = options\n\n  const remainingSlots = useMemo(\n    () => Math.max(0, maxTotal - (currentCount || 0)),\n    [currentCount, maxTotal]\n  )\n\n  const fileValidator = useCallback(() => {\n    if (!enabled) return null\n    if (remainingSlots === 0) {\n      return {\n        code: \"too-many-files\",\n        message: `You can only upload up to ${maxTotal} files.`,\n      } as any\n    }\n    return null\n  }, [enabled, remainingSlots, maxTotal])\n\n  const onDrop = useCallback(\n    (acceptedFiles: File[]) => {\n      if (!acceptedFiles?.length) return\n      const addCount = Math.max(0, remainingSlots)\n      const filesToAdd = acceptedFiles.slice(0, addCount)\n      if (filesToAdd.length) {\n        onFilesAccepted?.(filesToAdd)\n      }\n      if (acceptedFiles.length > filesToAdd.length) {\n        toast.error(`You can only upload up to ${maxTotal} files.`)\n      }\n    },\n    [onFilesAccepted, remainingSlots, maxTotal]\n  )\n\n  const onDropRejected = useCallback(\n    (rejectedFiles: any[]) => {\n      const hasTooManyFilesError = rejectedFiles.some((f) =>\n        f.errors.some((e: any) => e.code === \"too-many-files\")\n      )\n      const hasFileSizeError = rejectedFiles.some((f) =>\n        f.errors.some((e: any) => e.code === \"file-too-large\")\n      )\n      const hasFileTypeError = rejectedFiles.some((f) =>\n        f.errors.some((e: any) => e.code === \"file-invalid-type\")\n      )\n\n      if (hasTooManyFilesError) {\n        toast.error(`You can only upload up to ${maxTotal} files.`)\n      }\n      if (hasFileSizeError) {\n        toast.error(\"You can only upload files up to 5MB each.\")\n      }\n      if (hasFileTypeError) {\n        toast.error(\"You can only upload JPG and PNG files.\")\n      }\n    },\n    [maxTotal]\n  )\n\n  const { getRootProps, getInputProps, isDragActive, open } = useDropzone(\n    enabled\n      ? {\n          noClick: true,\n          noKeyboard: true,\n          multiple: true,\n          accept: {\n            \"image/jpeg\": [\".jpg\", \".jpeg\"],\n            \"image/png\": [\".png\"],\n          },\n          maxSize: maxSizeBytes,\n          // Avoid 0 = unlimited; leave validator to handle 0-slot case.\n          maxFiles: Math.max(1, remainingSlots),\n          validator: fileValidator,\n          onDrop,\n          onDropRejected,\n        }\n      : ({ disabled: true } as any)\n  )\n\n  return {\n    getRootProps,\n    getInputProps,\n    isDragActive,\n    open,\n    remainingSlots,\n  }\n}\n",
      "type": "registry:hook",
      "target": "components/stream-components/blocks/chat/hooks/useImageDropzone.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/hooks/useLocalStorage.ts",
      "content": "import { useEffect, useState } from \"react\"\n\n// Overload signatures\nexport function useLocalStorage<T>(\n  key: string,\n  initialValue: T\n): [T, (value: T) => void]\nexport function useLocalStorage<T = undefined>(\n  key: string\n): [T | undefined, (value: T) => void]\n\n// Implementation\nexport function useLocalStorage<T>(key: string, initialValue?: T) {\n  const [storedValue, setStoredValue] = useState<T | undefined>(() => {\n    try {\n      const item = window.localStorage.getItem(key)\n      if (item !== null) {\n        return JSON.parse(item)\n      }\n      return initialValue\n    } catch (error) {\n      return initialValue\n    }\n  })\n\n  useEffect(() => {\n    try {\n      const item = window.localStorage.getItem(key)\n      const parsed = item !== null ? JSON.parse(item) : initialValue\n\n      setStoredValue((prev) => {\n        const isEqual = JSON.stringify(prev) === JSON.stringify(parsed)\n        return isEqual ? prev : parsed\n      })\n    } catch {}\n  }, [key, initialValue])\n\n  const setValue = (value: T) => {\n    setStoredValue(value)\n    if (value === undefined) {\n      window.localStorage.removeItem(key)\n    } else {\n      window.localStorage.setItem(key, JSON.stringify(value))\n    }\n  }\n\n  return [storedValue, setValue] as\n    | [T, (value: T) => void]\n    | [T | undefined, (value: T) => void]\n}\n",
      "type": "registry:hook",
      "target": "components/stream-components/blocks/chat/hooks/useLocalStorage.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/hooks/useScrollAnchor.tsx",
      "content": "import React, { useCallback, useEffect, useRef, useState } from \"react\"\nimport { type UIMessage } from \"@ai-sdk/ui-utils\"\n\nexport interface ScrollAnchorProps {\n  messagesRef: React.RefObject<HTMLDivElement>\n  scrollRef: React.RefObject<HTMLDivElement>\n  scrollToBottom: () => void\n  isAtBottom: boolean\n}\n\nexport function useScrollAnchor(messages: UIMessage[]): ScrollAnchorProps {\n  const messagesRef = useRef<HTMLDivElement>({} as HTMLDivElement) // The container holding the messages\n  const scrollRef = useRef<HTMLDivElement>({} as HTMLDivElement) // The scrollable div itself\n  const lastScrollTopRef = useRef<number>(0)\n\n  const [isAtBottom, setIsAtBottom] = useState(true)\n  const [direction, setDirection] = useState<\"up\" | \"down\">(\"down\")\n\n  const scrollToBottom = useCallback(() => {\n    if (scrollRef.current) {\n      scrollRef.current.scrollTo({\n        top: scrollRef.current.scrollHeight,\n        behavior: \"smooth\",\n      })\n    }\n  }, [])\n\n  useEffect(() => {\n    if (messagesRef.current) {\n      const observer = new window.ResizeObserver(() => {\n        if (scrollRef.current && isAtBottom && direction === \"down\") {\n          scrollRef.current.scrollTo({\n            top: scrollRef.current.scrollHeight,\n            behavior: \"smooth\",\n          })\n        }\n      })\n\n      for (const child of messagesRef.current.children) {\n        observer.observe(child)\n      }\n\n      return () => {\n        observer.disconnect()\n      }\n    }\n  }, [messages.length, isAtBottom, direction])\n\n  useEffect(() => {\n    const { current } = scrollRef\n\n    if (current) {\n      const handleScroll = (event: Event) => {\n        const target = event.target as HTMLDivElement\n        const offset = 75 // Buffer for determining if you're near the bottom\n        const atBottom =\n          target.scrollTop + target.clientHeight >= target.scrollHeight - offset\n\n        setDirection(\n          target.scrollTop > lastScrollTopRef.current ? \"down\" : \"up\"\n        )\n        lastScrollTopRef.current = Math.max(0, target.scrollTop) // Prevent negative values\n\n        setIsAtBottom(atBottom)\n      }\n\n      current.addEventListener(\"scroll\", handleScroll, {\n        passive: true,\n      })\n\n      return () => {\n        current.removeEventListener(\"scroll\", handleScroll)\n      }\n    }\n  }, [])\n\n  return {\n    messagesRef,\n    scrollRef,\n    scrollToBottom,\n    isAtBottom,\n  }\n}\n",
      "type": "registry:hook",
      "target": "components/stream-components/blocks/chat/hooks/useScrollAnchor.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/hooks/useChatProvider.tsx",
      "content": "import { useContext } from 'react';\n\nimport { ChatContext } from '../stream-messages';\n\nexport const useChatProvider = () => {\n  const context = useContext(ChatContext);\n\n  if (context === undefined) {\n    throw new Error('useChatProvider must be used within a ChatProvider');\n  }\n\n  return context;\n};\n",
      "type": "registry:hook",
      "target": "components/stream-components/blocks/chat/hooks/useChatProvider.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/hooks/useAiChatProvider.tsx",
      "content": "import { useContext } from \"react\"\n\nimport { VercelAiUiContext } from \"../stream-messages\"\n\nexport const useAiChatProvider = () => {\n  const context = useContext(VercelAiUiContext)\n\n  if (context === undefined) {\n    throw new Error(\"useChatProvider must be used within a VercelAiProvider\")\n  }\n\n  return context\n}\n",
      "type": "registry:hook",
      "target": "components/stream-components/blocks/chat/hooks/useAiChatProvider.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/icons/RectangleStar.tsx",
      "content": "import React from \"react\"\n\nexport function RectangleStar({\n  fill = \"black\",\n}: {\n  fill?: string\n}): React.ReactNode {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"29\"\n      height=\"29\"\n      viewBox=\"0 0 29 29\"\n      fill=\"none\"\n    >\n      <path\n        d=\"M24.168 24.1668H4.83464C4.1937 24.1668 3.57901 23.9122 3.12579 23.459C2.67258 23.0058 2.41797 22.3911 2.41797 21.7502V7.25016C2.41797 6.60922 2.67258 5.99453 3.12579 5.54132C3.57901 5.08811 4.1937 4.8335 4.83464 4.8335H24.168C24.8089 4.8335 25.4236 5.08811 25.8768 5.54132C26.33 5.99453 26.5846 6.60922 26.5846 7.25016V21.7502C26.5846 22.3911 26.33 23.0058 25.8768 23.459C25.4236 23.9122 24.8089 24.1668 24.168 24.1668ZM4.83464 7.25016V21.7502H24.168V7.25016H4.83464Z\"\n        fill={fill}\n        fillOpacity=\"0.66\"\n      />\n      <path\n        d=\"M5.0013 0.416504L3.7513 3.74984L0.417969 4.99984L3.7513 6.24984L5.0013 9.58317L6.2513 6.24984L9.58463 4.99984L6.2513 3.74984L5.0013 0.416504Z\"\n        fill={fill}\n        fillOpacity=\"0.66\"\n        transform=\"translate(9.5, 9.5)\"\n      />\n    </svg>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/icons/RectangleStar.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/store/atoms.ts",
      "content": "import { atom } from \"jotai\"\nimport { isEmpty } from \"lodash\"\n\nimport { type ExtractSourceRecordProps } from \"../types\"\nimport {\n  type Artifacts,\n  type ArtifactsProperties,\n  type BrandKitDetailsModalStateOptions,\n  type Config,\n  type IsMessageAlreadyGeneratedProps,\n} from \"./types\"\n\nexport const configAtom = atom<Config>()\n\nexport const brandkitIdAtom = atom<string>(\"\")\n\nexport const chatIdAtom = atom<string>(\"\")\n\nexport const isNewChatAtom = atom<boolean>(false)\n\nexport const currentStreamingChatIdAtom = atom<string>(\"\")\n\nexport const apiQueueAtom = atom<{ [key: string]: string }>()\n\nexport const selectedChatWithIdAtom = atom<string>(\"\")\n\nexport const isApiQueueFullAtom = atom<boolean>(function (get) {\n  return !isEmpty(get(apiQueueAtom))\n})\n\nexport const artifactsAtom = atom(\n  {} as Artifacts,\n  function (_get, set, artifact: Artifacts) {\n    const prev = _get(artifactsAtom) as Artifacts\n\n    const resetPrev: Artifacts = Object.fromEntries(\n      Object.entries(prev).map(([key, value]) => [\n        key,\n        { ...value, open: false },\n      ])\n    )\n\n    set(artifactsAtom, { ...resetPrev, ...artifact })\n  }\n)\n\nexport const postChatGenerateBodyAtom = atom({})\n\nexport const messagesIdsAtom = atom<string[]>([])\n\nexport const isChatActionPendingAtom = atom<boolean>(false)\n\nexport const hasErrorAtom = atom<boolean>(false)\n\nexport const brandKitDetailsModalStateAtom =\n  atom<BrandKitDetailsModalStateOptions>(\"idle\")\n\nexport const isAnyArtifactOpenAtom = atom(function (get) {\n  const artifacts = get(artifactsAtom)\n\n  return Object.values(artifacts).some(\n    (isOpen) => (isOpen as ArtifactsProperties).open\n  )\n})\n\nexport const isMessageAlreadyGeneratedAtom =\n  atom<IsMessageAlreadyGeneratedProps>(function (get) {\n    return function (messageId: string = \"\"): boolean {\n      return !get(messagesIdsAtom).includes(messageId) && get(isLoadingAtom)\n    }\n  })\n\nexport const isLoadingAtom = atom<boolean>(false)\n\nexport const extractSourcesFromDataAtom = atom<\n  Record<string, ExtractSourceRecordProps>\n>({})\n\n// Holds transient added context (e.g., images as base64) across new-chat redirect\nexport const addedContextAtom = atom<\n  Array<{ type: \"image_base64\"; value: string }>\n>([])\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/store/atoms.ts"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/store/tools.ts",
      "content": "import { useCallback } from \"react\"\nimport { atom, useAtom } from \"jotai\"\nimport { atomWithReset } from \"jotai/utils\"\nimport type { PrimitiveAtom } from \"jotai\"\n\nexport const TOOL_ACTIONS = {\n  TOGGLE_BRAINSTORMING: \"TOGGLE_BRAINSTORMING\",\n  TOGGLE_BRIEF: \"TOGGLE_BRIEF\",\n  RESET_ALL_TOOLS: \"RESET_ALL_TOOLS\",\n  CONFIGURE_BRAINSTORMING: \"CONFIGURE_BRAINSTORMING\",\n} as const\n\nexport type ToolActionType = (typeof TOOL_ACTIONS)[keyof typeof TOOL_ACTIONS]\nexport type SearchType = \"web\" | \"knowledge\" | \"knowledge_web\"\n\nexport interface ToolState {\n  brainstorming: {\n    active: boolean\n    data: {\n      mode: \"brainstorming\"\n      params: {\n        searchType: SearchType\n      }\n    }\n  }\n  contentOpsBrief: {\n    active: boolean\n    data?: any\n  }\n}\n\nconst initialToolState: ToolState = {\n  brainstorming: {\n    active: false,\n    data: {\n      mode: \"brainstorming\",\n      params: {\n        searchType: \"knowledge_web\",\n      },\n    },\n  },\n  contentOpsBrief: {\n    active: false,\n  },\n}\n\nexport const toolStateAtom = atomWithReset<ToolState>(initialToolState)\ntoolStateAtom.debugLabel = \"toolStateAtom\"\n\nexport interface ToolAction {\n  type: ToolActionType\n  payload?: any\n}\n\n// Reducer\nexport const toolReducer = (state: ToolState, action: ToolAction): ToolState => {\n  switch (action.type) {\n    case TOOL_ACTIONS.TOGGLE_BRAINSTORMING: {\n      const isCurrentlyActive = state.brainstorming.active\n      return {\n        ...state,\n        contentOpsBrief: { ...state.contentOpsBrief, active: false },\n        brainstorming: {\n          ...state.brainstorming,\n          active: !isCurrentlyActive,\n        },\n      }\n    }\n\n    case TOOL_ACTIONS.CONFIGURE_BRAINSTORMING: {\n      return {\n        ...state,\n        brainstorming: {\n          ...state.brainstorming,\n          data: {\n            ...state.brainstorming.data,\n            params: {\n              searchType: action.payload.searchType,\n            },\n          },\n        },\n      }\n    }\n\n    case TOOL_ACTIONS.TOGGLE_BRIEF: {\n      const isCurrentlyActive = state.contentOpsBrief.active\n      return {\n        ...state,\n        brainstorming: { ...state.brainstorming, active: false },\n        contentOpsBrief: {\n          ...state.contentOpsBrief,\n          active: !isCurrentlyActive,\n        },\n      }\n    }\n\n    case TOOL_ACTIONS.RESET_ALL_TOOLS: {\n      return initialToolState\n    }\n\n    default:\n      console.error(`Unknown tool action: ${action.type}`)\n      return state\n  }\n}\n\nexport function useReducerAtom<Value, Action>(\n  anAtom: PrimitiveAtom<Value>,\n  reducer: (v: Value, a: Action) => Value\n) {\n  const [state, setState] = useAtom(anAtom)\n  const dispatch = useCallback(\n    (action: Action) => setState((prev) => reducer(prev, action)),\n    [setState, reducer]\n  )\n\n  return [state, dispatch] as const\n}\n\n// Dispatcher\nexport function useToolDispatch() {\n  const [state, setState] = useAtom(toolStateAtom)\n  const dispatch = useCallback(\n    (action: ToolAction) =>\n      setState((prev) => {\n        if (typeof prev === \"symbol\") return initialToolState\n        return toolReducer(prev, action)\n      }),\n    [setState]\n  )\n  return [state, dispatch] as const\n}\n\n// Selectors\nexport const brainstormingStateAtom = atom((get) => get(toolStateAtom).brainstorming)\nexport const briefStateAtom = atom((get) => get(toolStateAtom).contentOpsBrief)\nexport const isAnyToolActiveAtom = atom((get) => {\n  const state = get(toolStateAtom)\n  return Object.values(state).some((tool) => tool.active)\n})\nexport const activeToolNameAtom = atom((get) => {\n  const state = get(toolStateAtom)\n  return (\n    (Object.keys(state) as (keyof ToolState)[]).find(\n      (toolName) => state[toolName].active\n    ) || null\n  )\n})\n\nexport const activeToolDataAtom = atom((get) => {\n  const state = get(toolStateAtom)\n  const activeTool = Object.values(state).find((tool) => tool.active)\n\n  return activeTool?.data\n})",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/store/tools.ts"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/store/toolDefinitions.ts",
      "content": "import { mdiFileDocumentOutline, mdiTextLong } from \"@mdi/js\"\n\nimport { TOOL_ACTIONS, type ToolActionType } from \"./tools\"\n\nexport type ToolDefinition = {\n  name: string\n  key: string\n  description?: string\n  icon: string\n  action: ToolActionType\n}\n\nexport const toolDefinitions: ToolDefinition[] = [\n  {\n    name: \"Brainstorming\",\n    key: \"brainstorming\",\n    description: \"Create long form content (e.g. blogs, articles)\",\n    icon: mdiTextLong,\n    action: TOOL_ACTIONS.TOGGLE_BRAINSTORMING,\n  },\n  {\n    name: \"Brief\",\n    key: \"contentOpsBrief\",\n    description: \"Generate content with contenthub ops briefs\",\n    icon: mdiFileDocumentOutline,\n    action: TOOL_ACTIONS.TOGGLE_BRIEF,\n  },\n]\n\nexport const toolList = toolDefinitions\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/store/toolDefinitions.ts"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/store/types.ts",
      "content": "import { type UseChatHelpers } from \"ai/react\"\n\nimport { type ExamplePrompt } from \"../EmptyScreenBoxes.jsx\"\n\nexport interface ArtifactsProperties {\n  open: boolean\n}\n\nexport interface Artifacts {\n  [key: string]: ArtifactsProperties\n}\n\nexport type BrainstormingSearchTypeOptions =\n  | \"web\"\n  | \"knowledge\"\n  | \"knowledge_web\"\n\nexport type BrainstormingOptions =\n  | {\n      mode: \"brainstorming\"\n      params: {\n        searchType: BrainstormingSearchTypeOptions\n      }\n    }\n  | {\n      mode: \"web_search\"\n      params: never\n    }\n  | undefined\n\nexport type BrandKitDetailsModalStateOptions = \"create\" | \"edit\" | \"idle\"\n\nexport type IsMessageAlreadyGeneratedProps = (message: string) => boolean\n\nexport type UserChatParams = UseChatHelpers & {\n  addToolResult: ({\n    toolCallId,\n    result,\n  }: {\n    toolCallId: string\n    result: unknown\n  }) => void\n}\n\nexport interface Session {\n  orgId: string\n  userId: string\n  region: string\n  env: \"dev\" | \"qa\" | \"staging\" | \"preprod\" | \"prod\"\n  token: string\n  apiEnv?: string\n}\n\nexport interface Config {\n  disclaimer?: string | React.ReactNode\n  examplePrompts?: ExamplePrompt[]\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/store/types.ts"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/tools/Tool.tsx",
      "content": "import React from \"react\"\n\nimport { cn } from \"../../../lib/utils\"\n\ninterface ToolProps {\n  testId?: string\n  children: React.ReactNode | React.ReactNode[]\n  className?: string\n}\n\nexport function Tool({\n  testId = \"tool\",\n  children,\n  className,\n}: ToolProps): React.ReactNode {\n  return (\n    <div\n      className={cn(\n        \"stream-chat-container group relative flex flex-col items-start gap-4\",\n        className\n      )}\n    >\n      <div className=\"flex w-full flex-col\">\n        <div className=\"col-span-4 flex flex-col gap-4\">\n          <div className=\"flex flex-col gap-4\">\n            <div className=\"relative space-y-3\" data-testid={`${testId}`}>\n              {children}\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/tools/Tool.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/tools/Answer.tsx",
      "content": "import React, { useMemo } from \"react\"\n\nimport { Markdown } from \"../Markdown\"\nimport { type ToolProps } from \"../types\"\nimport { replaceNewLines } from \"../utils\"\nimport { Tool } from \"./Tool\"\n\ninterface AnswerProps {\n  args: {\n    answer?: string\n    result?: {\n      answer?: string\n    }\n  }\n}\n\nexport function Answer({ toolInvocation }: ToolProps): React.ReactNode {\n  const { args } = toolInvocation\n  const { answer: streamAnswer = \"\", result: { answer = \"\" } = {} } =\n    args ?? ({} as AnswerProps)\n\n  /* Computed */\n  const content = useMemo(() => streamAnswer || answer, [answer, streamAnswer])\n\n  if (!content?.length) return null\n\n  return (\n    <Tool className=\"border-none px-0 py-2\">\n      <Markdown id=\"answer\" text={replaceNewLines(content)} />\n    </Tool>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/tools/Answer.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/tools/Sources.tsx",
      "content": "import React from \"react\"\n\nimport { Anchors } from \"../Anchors\"\nimport { LightBox } from \"../LightBox\"\nimport type { Source } from \"../types\"\n\nexport interface SourcesProps {\n  testId?: string\n  sources: Source[]\n}\n\nexport function Sources({\n  testId = \"sources\",\n  sources,\n}: SourcesProps): React.ReactNode {\n  if (!sources?.length) return null\n\n  const urls = sources.filter(\n    ({ type, url }) => type !== \"image\" && !!url?.length\n  )\n  const images = sources.filter(\n    ({ type, url }) => type === \"image\" && !!url?.length\n  )\n\n  return (\n    <div data-testid={testId} className=\"flex flex-col\">\n      <LightBox images={images} />\n      <Anchors testId={testId} items={urls} />\n    </div>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/tools/Sources.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/tools/ThinkingTool.tsx",
      "content": "import React, { useMemo } from \"react\"\nimport { useAtomValue } from \"jotai\"\n\nimport { Markdown } from \"../Markdown\"\nimport { MessageSubtitle } from \"../MessageSubtitle\"\nimport { isMessageAlreadyGeneratedAtom } from \"../store/atoms\"\nimport { type ToolProps } from \"../types\"\nimport { replaceNewLines } from \"../utils\"\nimport { Sources } from \"./Sources\"\nimport { Tool } from \"./Tool\"\n\nexport type ThinkingToolProps = ToolProps & {\n  title?: string\n  icon?: string\n}\n\nexport function ThinkingTool({\n  icon,\n  messageId,\n  toolInvocation,\n  title = \"\",\n}: ThinkingToolProps): React.ReactNode {\n  const {\n    args: { result = \"\", arguments: { answer = \"\" } = {}, data = {} } = {},\n  } = toolInvocation ?? {}\n\n  /* Atoms */\n  const isMessageAlreadyGenerated = useAtomValue(isMessageAlreadyGeneratedAtom)(\n    messageId\n  )\n\n  /* Computed */\n  const content = useMemo(() => answer || result, [answer, result])\n  const contentTestId = title.split(\" \").join(\"_\").toLowerCase()\n\n  if (!content?.length) return null\n\n  return (\n    <Tool className=\"rounded-lg border border-[#F7F7F7] bg-white p-2 py-3\">\n      <MessageSubtitle\n        isGenerating={isMessageAlreadyGenerated}\n        icon={icon}\n        title={title}\n      />\n      <Markdown text={replaceNewLines(content)} id={`thinking_tool`} />\n      <Sources testId={`${contentTestId}`} sources={data?.sources} />\n    </Tool>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/tools/ThinkingTool.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/tools/ToolInvocations.tsx",
      "content": "\"use client\"\n\nimport React from \"react\"\nimport { useAtomValue } from \"jotai\"\nimport { isEmpty } from \"lodash\"\n\nimport { Reveal } from \"../artifacts/Reveal\"\nimport { isMessageAlreadyGeneratedAtom } from \"../store/atoms\"\nimport {\n  type ToolInvocationRefProps,\n  type ToolInvocationsProps,\n} from \"../types\"\nimport { createTool } from \"./utils/createTool\"\n\nexport function ToolInvocations({\n  messageId,\n  message,\n  toolInvocations,\n  isLastMessage,\n}: ToolInvocationsProps): React.ReactNode {\n  /* Atoms */\n  const isMessageAlreadyGenerated = useAtomValue(isMessageAlreadyGeneratedAtom)(\n    messageId\n  )\n\n  const thinkingTools: React.ReactNode[] = []\n  const brainstormingTools: React.ReactNode[] = []\n  const restTools: React.ReactNode[] = []\n\n  toolInvocations.forEach((toolInvocation: ToolInvocationRefProps) => {\n    const { toolName } = toolInvocation\n\n    const tool = createTool({ messageId, message, toolInvocation })\n    if (!tool) return\n\n    if (toolName === \"brainstorming\") {\n      brainstormingTools.push(tool)\n      return\n    }\n    if (toolName === \"brief\" || toolName === \"answer\") {\n      restTools.push(tool)\n      return\n    }\n    if (toolName === \"followup_questions\") {\n      if (isLastMessage) restTools.push(tool)\n      return\n    }\n    thinkingTools.push(tool)\n  })\n\n  return (\n    <>\n      {!isEmpty(thinkingTools) && (\n        <Reveal\n          isGenerating={isMessageAlreadyGenerated}\n          titleStreamStart=\"Thinking\"\n          titleStreamEnd=\"Thinking\"\n          id=\"thinking_tools\"\n          isExpandable\n        >\n          {thinkingTools}\n        </Reveal>\n      )}\n      {!isEmpty(brainstormingTools) && brainstormingTools}\n      {!isEmpty(restTools) && restTools}\n    </>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/tools/ToolInvocations.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/tools/FollowupQuestions.tsx",
      "content": "import React, { useEffect, useMemo, useRef } from \"react\"\nimport { mdiArrowRight } from \"@mdi/js\"\nimport { useAtomValue } from \"jotai\"\n\nimport { Button } from \"@/registry/new-york/ui/button\"\n\nimport { Reveal } from \"../artifacts/Reveal\"\nimport { useAiChatProvider } from \"../hooks/useAiChatProvider\"\nimport { Icon } from \"../Icon\"\nimport { isMessageAlreadyGeneratedAtom } from \"../store/atoms\"\nimport { type ToolProps } from \"../types\"\n\ninterface Question {\n  question: string\n}\n\ninterface Questions {\n  questions: Question[]\n}\n\nexport function FollowupQuestions({\n  messageId,\n  toolInvocation,\n}: ToolProps): React.ReactNode {\n  const {\n    args: { questions = [] as Question[], result = {} as Questions } = {},\n  } = toolInvocation ?? {}\n\n  const { setInput } = useAiChatProvider()\n\n  /* Atoms */\n  const isMessageAlreadyGenerated = useAtomValue(isMessageAlreadyGeneratedAtom)(\n    messageId\n  )\n\n  /* Computed */\n  const content: Question[] = useMemo(\n    () => (questions.length ? questions : result?.questions),\n    [questions, result?.questions]\n  )\n\n  const wrapperRef = useRef<HTMLDivElement>(null)\n  const wasAtBottom = useRef<boolean>(false)\n\n  useEffect(() => {\n    if (wasAtBottom.current) scrollToBottom()\n  }, [content])\n\n  if (!content?.length) return null\n\n  const scrollToBottom = (): void => {\n    wrapperRef.current?.scrollIntoView({ behavior: \"smooth\" })\n  }\n\n  return (\n    <Reveal\n      id=\"followup_questions\"\n      isGenerating={isMessageAlreadyGenerated}\n      title=\"Suggested follow-up questions\"\n      position=\"right\"\n      className=\"border-none bg-transparent\"\n    >\n      <div\n        className=\"flex max-w-fit flex-col gap-2 text-right\"\n        ref={wrapperRef}\n      >\n        {content.map(({ question }, index) => (\n          <Button\n            data-testid={`chat_follow_up_questions_dropdown_${index}_open`}\n            key={`${question}_${index}`}\n            variant=\"outline\"\n            className=\"text-body-text h-auto w-full justify-end rounded-xl px-4 py-2 text-left text-lg font-normal\"\n            style={{\n              textWrap: \"wrap\",\n            }}\n            onClick={() => setInput(question)}\n          >\n            <span className=\"block flex-1\">{question}</span>\n            <Icon\n              path={mdiArrowRight}\n              size=\"2xs\"\n              className=\"text-blackAlpha-500 ml-2\"\n            />\n          </Button>\n        ))}\n      </div>\n    </Reveal>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/tools/FollowupQuestions.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/tools/utils/createTool.tsx",
      "content": "import React, { Fragment } from \"react\"\nimport { mdiCheckboxMarkedCircleOutline, mdiWeb } from \"@mdi/js\"\n\nimport { type ToolProps, type Tools } from \"../../types\"\nimport { Answer } from \"../Answer\"\nimport { Brainstorming } from \"../brainstorming/Brainstorming\"\nimport { Brief } from \"../brief/Brief\"\nimport { FollowupQuestions } from \"../FollowupQuestions\"\nimport { ThinkingTool } from \"../ThinkingTool\"\n\nconst TOOLS: Tools = {\n  knowledge_search(props): React.ReactNode {\n    return (\n      <ThinkingTool\n        title=\"Searched brand knowledge\"\n        icon={mdiCheckboxMarkedCircleOutline}\n        {...props}\n      />\n    )\n  },\n  web_search(props): React.ReactNode {\n    return <ThinkingTool title=\"Search the web\" icon={mdiWeb} {...props} />\n  },\n  brand_knowledge(props): React.ReactNode {\n    return (\n      <ThinkingTool\n        title=\"Used brand kit sections\"\n        icon={mdiCheckboxMarkedCircleOutline}\n        {...props}\n      />\n    )\n  },\n  answer(props): React.ReactNode {\n    return <Answer {...props} />\n  },\n  followup_questions(props): React.ReactNode {\n    return <FollowupQuestions {...props} />\n  },\n  brief(props): React.ReactNode {\n    return <Brief {...props} />\n  },\n  brainstorming(props): React.ReactNode {\n    return <Brainstorming {...props} />\n  },\n}\n\nexport function createTool({\n  id,\n  messageId,\n  message,\n  toolInvocation,\n}: ToolProps): React.ReactNode {\n  const { toolName, toolCallId } = toolInvocation\n\n  if (!TOOLS[toolName]) return null\n\n  return (\n    <Fragment key={`${toolName}_${toolCallId}`}>\n      {\n        TOOLS[toolName]({\n          id,\n          messageId,\n          message,\n          toolInvocation,\n        }) as React.ReactNode\n      }\n    </Fragment>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/tools/utils/createTool.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/tools/brief/Brief.tsx",
      "content": "import React, { useEffect, useMemo, useRef } from \"react\"\nimport { type ListBriefVersionSectionFieldsResponseModel } from \"@sitecore/stream-ui-core\"\nimport { useAtomValue } from \"jotai\"\n\nimport { Button } from \"@/registry/new-york/ui/button\"\n\nimport { PreviewAside } from \"../../artifacts/PreviewAside\"\nimport EditCommands from \"../../EditCommands\"\nimport { Markdown } from \"../../Markdown\"\nimport { chatIdAtom, isLoadingAtom } from \"../../store/atoms\"\nimport { type ToolProps } from \"../../types\"\nimport { useBriefLogic } from \"./useBriefLogic\"\n\nexport function Brief({\n  messageId,\n  toolInvocation,\n}: ToolProps): React.ReactNode {\n  const { args } = toolInvocation\n  const mainContent = useMemo(() => args?.result ?? {}, [args?.result])\n\n  /* IDs */\n  const briefId = mainContent?.id\n\n  /* Hooks */\n  const {\n    isActionPending,\n    versions,\n    artifactContentRef,\n    handleGetBriefVersions,\n    handleMainContentOnInput,\n    handleSetVersionOnSelect,\n    handleArtifactContentOnBlur,\n    handleCopyTextOnClick,\n    handleExportBriefToDocx,\n    handleArtifactContentNewVersion,\n  } = useBriefLogic(briefId)\n  const mounted = useRef<boolean>(false)\n  const exportMarkdownRef = useRef<HTMLDivElement>(null)\n\n  /* Atoms */\n  const isLoading = useAtomValue(isLoadingAtom)\n  const chatId = useAtomValue(chatIdAtom)\n\n  /* Flags */\n  const isMainContentAvailable = !!Object.keys(mainContent).length\n  const canRender =\n    !!chatId?.length && !mounted.current && isMainContentAvailable\n  const hasLatestData = !isLoading && briefId && messageId\n\n  /* Effects */\n  /* Init */\n  useEffect(() => {\n    if (canRender) {\n      // Streaming\n      artifactContentRef.current = mainContent\n\n      /* Get the latest version if using chat history */\n      if (hasLatestData) {\n        // History\n        mounted.current = true\n        artifactContentRef.current = mainContent\n        handleGetBriefVersions()\n      }\n    }\n  }, [\n    artifactContentRef,\n    handleGetBriefVersions,\n    hasLatestData,\n    canRender,\n    mainContent,\n  ])\n\n  return (\n    <section className=\"flex flex-col space-y-5\">\n      <h4 className=\"text-md text-blackAlpha-900\">Here is your brief...</h4>\n      <PreviewAside\n        id=\"brief\"\n        versions={versions}\n        buttonTitle={mainContent?.name}\n        isActionPending={isActionPending}\n        onSelectVersion={handleSetVersionOnSelect}\n        onSelectNewVersion={handleArtifactContentNewVersion}\n        footerContent={{\n          end: (\n            <>\n              <EditCommands>\n                <EditCommands.Copy\n                  onClick={handleCopyTextOnClick}\n                ></EditCommands.Copy>\n              </EditCommands>\n              <Button\n                onClick={() =>\n                  handleExportBriefToDocx(exportMarkdownRef.current!)\n                }\n              >\n                Export\n              </Button>\n            </>\n          ),\n        }}\n      >\n        {isMainContentAvailable && (\n          <div\n            ref={exportMarkdownRef}\n            data-testid={`brief_content`}\n            className=\"flex w-full flex-col\"\n          >\n            {artifactContentRef.current?.sections?.map(\n              (section, index: number) => {\n                /* Skip the first section */\n                if (index === 0) return null\n\n                const {\n                  id: sectionId,\n                  name: sectionName,\n                  fields,\n                } = section ?? {}\n\n                return (\n                  <div key={`section_${sectionId}_${index}`}>\n                    <div className=\"mt-4 flex flex-col\">\n                      {sectionName && (\n                        <h2\n                          contentEditable={!isActionPending}\n                          suppressContentEditableWarning\n                          onChange={(e) =>\n                            handleMainContentOnInput(e, [\n                              \"sections\",\n                              String(index),\n                              \"name\",\n                            ])\n                          }\n                          onBlur={(e) =>\n                            handleArtifactContentOnBlur(e, {\n                              type: \"section\",\n                              section,\n                              path: [\"sections\", String(index), \"name\"],\n                            })\n                          }\n                          className=\"stream-chat-editable text-3xl font-semibold text-black\"\n                        >\n                          {sectionName}\n                        </h2>\n                      )}\n                      {fields?.map(\n                        (\n                          field: ListBriefVersionSectionFieldsResponseModel,\n                          idx: number\n                        ) => {\n                          const { id: fieldId, name: fieldName } = field\n                          const value = Array.isArray(field.value)\n                            ? field.value\n                                .map((val) => (val as { name: string }).name)\n                                .join(\" \")\n                            : (field.value as string)\n\n                          return (\n                            <div\n                              key={`field_${fieldId}_${idx}`}\n                              className=\"mt-4 flex flex-col\"\n                            >\n                              {fieldName && (\n                                <h3\n                                  contentEditable={!isActionPending}\n                                  suppressContentEditableWarning\n                                  onChange={(e) =>\n                                    handleMainContentOnInput(e, [\n                                      \"sections\",\n                                      String(index),\n                                      \"fields\",\n                                      String(idx),\n                                      \"name\",\n                                    ])\n                                  }\n                                  onBlur={(e) =>\n                                    handleArtifactContentOnBlur(e, {\n                                      type: \"field\",\n                                      section,\n                                      field,\n                                      path: [\n                                        \"sections\",\n                                        String(index),\n                                        \"fields\",\n                                        String(idx),\n                                        \"name\",\n                                      ],\n                                    })\n                                  }\n                                  className=\"stream-chat-editable text-xl font-semibold text-black\"\n                                >\n                                  {fieldName}\n                                </h3>\n                              )}\n                              {fieldName && (\n                                <div\n                                  contentEditable={!isActionPending}\n                                  suppressContentEditableWarning\n                                  onChange={(e) =>\n                                    handleMainContentOnInput(e, [\n                                      \"sections\",\n                                      String(index),\n                                      \"fields\",\n                                      String(idx),\n                                      \"value\",\n                                    ])\n                                  }\n                                  onBlur={(e) =>\n                                    handleArtifactContentOnBlur(e, {\n                                      type: \"field\",\n                                      section,\n                                      field,\n                                      path: [\n                                        \"sections\",\n                                        String(index),\n                                        \"fields\",\n                                        String(idx),\n                                        \"value\",\n                                      ],\n                                    })\n                                  }\n                                  className=\"stream-chat-editable text-blackAlpha-600 text-md mt-4 font-normal\"\n                                >\n                                  <Markdown id=\"brief\" text={value} />\n                                </div>\n                              )}\n                            </div>\n                          )\n                        }\n                      )}\n                    </div>\n                  </div>\n                )\n              }\n            )}\n          </div>\n        )}\n      </PreviewAside>\n    </section>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/tools/brief/Brief.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/tools/brief/useBriefLogic.tsx",
      "content": "import React, { useCallback, useRef, useState, type FormEvent } from \"react\"\nimport {\n  brief,\n  HTTPError,\n  type FieldsModel,\n  type ListBriefVersionSectionFieldsResponseModel,\n  type ListBriefVersionSectionsModel,\n} from \"@sitecore/stream-ui-core\"\nimport { useSetAtom } from \"jotai\"\nimport { cloneDeep, get, omit, pick, set } from \"lodash\"\nimport { toast } from \"sonner\"\n\nimport {\n  setPreviewAsideMaxVersions,\n  type PreviewAsideVersions,\n} from \"../../artifacts/PreviewAside\"\nimport { useChatProvider } from \"../../hooks/useChatProvider\"\nimport { apiQueueAtom } from \"../../store/atoms\"\nimport { type HTTPValidationError } from \"../../types\"\nimport {\n  copyToClipboard,\n  htmlToMarkdown,\n  saveToDocx,\n  STRIP_TEXT_REGEX,\n} from \"../../utils\"\n\nexport type SectionProps = ListBriefVersionSectionsModel & {\n  fields: ListBriefVersionSectionFieldsResponseModel[]\n}\n\nexport interface Sections {\n  sections?: SectionProps[]\n}\n\nexport interface UseBriefLogicProps {\n  isActionPending: boolean\n  versions: PreviewAsideVersions\n  artifactContentRef: React.MutableRefObject<Sections>\n  handleGetBriefVersions: (versionNumber?: string) => Promise<void>\n  handleSetVersionOnSelect: (versionNumber: string) => Promise<void>\n  handleMainContentOnInput: (\n    e: FormEvent<HTMLDivElement>,\n    path: string[]\n  ) => void\n  handleArtifactContentOnBlur: (\n    e: FormEvent<HTMLDivElement>,\n    {\n      type,\n      section,\n      field,\n      path,\n    }: {\n      type: \"section\" | \"field\"\n      section: SectionProps\n      field?: ListBriefVersionSectionFieldsResponseModel\n      path: string[]\n    }\n  ) => Promise<void>\n  handleCopyTextOnClick: () => void\n  handleExportBriefToDocx: (markdownElement: HTMLDivElement) => void\n  handleArtifactContentNewVersion: () => Promise<void>\n}\n\nexport function useBriefLogic(briefId: string): UseBriefLogicProps {\n  /* Hooks */\n  const { session } = useChatProvider()\n  const [versions, setVersions] = useState<PreviewAsideVersions>({\n    selected: \"\",\n    available: [],\n  })\n  const [initialSectionsLength, setInitialSectionsLength] = useState<number>(0)\n  const [unSavedArtifactContent, setUnSavedArtifactContent] =\n    useState<Sections>()\n  const [isActionPending, setIsActionPending] = useState(false)\n  const artifactContentRef = useRef<Sections>({})\n\n  /* Atoms */\n  const setApiQueue = useSetAtom(apiQueueAtom)\n\n  const getInitialSectionsLength = useCallback(async () => {\n    setApiQueue((prev) => ({ ...prev, getBriefVersionSections: briefId }))\n    try {\n      const { data = [] } =\n        await brief.listBriefVersionSectionsApiBrandsV1OrganizationsOrganizationIdBriefsBriefIdVersionsVersionNumberSectionsGet(\n          {\n            path: {\n              briefId,\n              versionNumber: \"1\",\n              organizationId: session.orgId,\n            },\n          }\n        )\n\n      setInitialSectionsLength(data.length)\n    } catch (error: unknown) {\n      const { response } = error as HTTPError\n      toast.error(response.statusText)\n      setIsActionPending(false)\n    } finally {\n      setApiQueue((prev) => omit(prev, [\"getBriefVersionSections\"]))\n    }\n  }, [briefId, session.orgId, setApiQueue])\n\n  const handleGetBriefVersions = useCallback(\n    async (versionNumber?: string) => {\n      setIsActionPending(true)\n\n      /* Create the brief from scratch */\n      if (versionNumber) {\n        setApiQueue((prev) => ({ ...prev, getBriefVersionSections: briefId }))\n\n        let sectionsData = null\n\n        try {\n          const { data } =\n            await brief.listBriefVersionSectionsApiBrandsV1OrganizationsOrganizationIdBriefsBriefIdVersionsVersionNumberSectionsGet(\n              {\n                path: {\n                  briefId,\n                  versionNumber,\n                  organizationId: session.orgId,\n                },\n              }\n            )\n          sectionsData = data\n        } catch (error: unknown) {\n          const { response } = error as HTTPError\n          toast.error(response.statusText)\n          setIsActionPending(false)\n        }\n\n        setApiQueue((prev) => omit(prev, [\"getBriefVersionSections\"]))\n        setApiQueue((prev) => ({\n          ...prev,\n          getBriefSectionVersionFields: briefId,\n        }))\n\n        const sections = await Promise.all(\n          // The BE is returning all the sections, even the previous ones. We only need the last ones.\n          sectionsData?.slice(-initialSectionsLength).map(async (section) => {\n            let fields = null\n\n            try {\n              const { data } =\n                await brief.listBriefVersionSectionFieldsApiBrandsV2OrganizationsOrganizationIdBriefsBriefIdVersionsVersionNumberSectionsSectionIdFieldsGet(\n                  {\n                    path: {\n                      briefId,\n                      versionNumber,\n                      organizationId: session.orgId,\n                      sectionId: section.id,\n                    },\n                  }\n                )\n              fields = data\n            } catch (error: unknown) {\n              const { response } = error as HTTPError\n              toast.error(response.statusText)\n              setIsActionPending(false)\n            }\n\n            setApiQueue((prev) => omit(prev, [\"getBriefSectionVersionFields\"]))\n\n            return {\n              ...section,\n              fields: fields ?? [],\n            }\n          }) ?? []\n        )\n\n        artifactContentRef.current = {\n          ...artifactContentRef.current,\n          sections,\n        }\n\n        setUnSavedArtifactContent((prev) => ({ ...prev, sections }))\n        setIsActionPending(false)\n      } else {\n        setApiQueue((prev) => ({ ...prev, getBrief: briefId }))\n        try {\n          const { data } =\n            await brief.getBriefApiBrandsV1OrganizationsOrganizationIdBriefsBriefIdGet(\n              {\n                path: {\n                  briefId,\n                  organizationId: session.orgId,\n                },\n              }\n            )\n\n          setVersions({\n            selected: data?.version ?? \"\",\n            available: setPreviewAsideMaxVersions(data?.version ?? \"\"),\n          })\n          if (!initialSectionsLength) await getInitialSectionsLength()\n          await handleGetBriefVersions(data?.version)\n        } catch (error: unknown) {\n          const { response } = error as HTTPError\n          toast.error(response.statusText)\n          setIsActionPending(false)\n        } finally {\n          setApiQueue((prev) => omit(prev, [\"getBrief\"]))\n        }\n      }\n    },\n    [\n      briefId,\n      getInitialSectionsLength,\n      initialSectionsLength,\n      session.orgId,\n      setApiQueue,\n    ]\n  )\n\n  const handleSetVersionOnSelect = async (\n    versionNumber: string\n  ): Promise<void> => {\n    setVersions((prev) => ({ ...prev, selected: versionNumber }))\n    await handleGetBriefVersions(versionNumber)\n  }\n\n  const handleMainContentOnInput = (\n    e: FormEvent<HTMLDivElement>,\n    path: string[]\n  ): void => {\n    const parent = e.target as HTMLDivElement\n    const contentValue = htmlToMarkdown(String(parent?.innerHTML))\n\n    artifactContentRef.current = set(\n      cloneDeep(artifactContentRef.current) as Sections,\n      path,\n      contentValue\n    )\n  }\n\n  const handleArtifactContentOnBlur = async (\n    e: FormEvent<HTMLDivElement>,\n    {\n      type,\n      section,\n      field,\n      path,\n    }: {\n      type: \"section\" | \"field\"\n      section: SectionProps\n      field?: ListBriefVersionSectionFieldsResponseModel\n      path: string[]\n    }\n  ): Promise<void> => {\n    const parent = e.target as HTMLDivElement\n    const contentValue = htmlToMarkdown(String(parent?.innerHTML)) ?? \"\"\n\n    /* If unchanged, do not update */\n    if (type === \"field\") {\n      const fieldValue = get(unSavedArtifactContent, path)\n      const value = Array.isArray(fieldValue)\n        ? fieldValue.map((val: FieldsModel) => val.name).join(\"\")\n        : fieldValue\n\n      if (\n        value.replace(STRIP_TEXT_REGEX, \"\") ===\n        contentValue.replace(STRIP_TEXT_REGEX, \"\")\n      ) {\n        return\n      }\n    }\n    if (type === \"section\") {\n      if (\n        get(unSavedArtifactContent, path)?.replace(STRIP_TEXT_REGEX, \"\") ===\n        contentValue?.replace(STRIP_TEXT_REGEX, \"\")\n      ) {\n        return\n      }\n    }\n\n    setIsActionPending(true)\n\n    switch (type) {\n      case \"section\":\n        try {\n          const patchSectionRes = await fetch(\n            `https://ai-brief-api-${session.apiEnv}/api/brands/v1/organizations/${session.orgId}/briefs/${briefId}/sections/${section.id}`,\n            {\n              method: \"PATCH\",\n              body: JSON.stringify(\n                pick({ ...section, name: contentValue }, [\n                  \"deletable\",\n                  \"name\",\n                  \"order\",\n                ])\n              ),\n              headers: {\n                \"Content-Type\": \"application/json\",\n                ...(session?.token\n                  ? { Authorization: `Bearer ${session?.token}` }\n                  : {}),\n              },\n            }\n          )\n\n          if (!patchSectionRes.ok) {\n            throw patchSectionRes\n          }\n\n          await handleGetBriefVersions()\n        } catch (error: unknown) {\n          const { detail } = error as HTTPValidationError\n          toast.error(detail[0]?.msg)\n        } finally {\n          setIsActionPending(false)\n        }\n        break\n      case \"field\": {\n        let fieldValue = {}\n\n        if (path.includes(\"name\")) {\n          const value = Array.isArray(field?.value)\n            ? field.value.map((val) => (val as { name: string }).name).join(\"\")\n            : field?.value\n\n          fieldValue = {\n            ...field,\n            name: contentValue,\n            value,\n          }\n        }\n\n        if (path.includes(\"value\")) {\n          fieldValue = {\n            ...field,\n            value: contentValue,\n          }\n        }\n\n        try {\n          const patchFieldRes = await fetch(\n            `https://ai-brief-api-${session.apiEnv}/api/brands/v2/organizations/${session.orgId}/briefs/${briefId}/sections/${section.id}/fields/${field?.id ?? \"\"}`,\n            {\n              method: \"PATCH\",\n              body: JSON.stringify(\n                pick(fieldValue, [\n                  \"deletable\",\n                  \"name\",\n                  \"order\",\n                  \"value\",\n                  \"intent\",\n                  \"aiEditable\",\n                  \"verified\",\n                ]) as FieldsModel\n              ),\n              headers: {\n                \"Content-Type\": \"application/json\",\n                ...(session?.token\n                  ? { Authorization: `Bearer ${session?.token}` }\n                  : {}),\n              },\n            }\n          )\n\n          if (!patchFieldRes.ok) {\n            throw patchFieldRes\n          }\n\n          await handleGetBriefVersions()\n        } catch (error: unknown) {\n          const { detail } = error as HTTPValidationError\n          toast.error(detail[0]?.msg)\n        } finally {\n          setIsActionPending(false)\n        }\n        break\n      }\n    }\n  }\n\n  const handleArtifactContentNewVersion = async (): Promise<void> => {\n    setIsActionPending(true)\n\n    const section = artifactContentRef.current?.sections?.[1]\n    const { id, name } = section as SectionProps\n\n    try {\n      const patchSectionRes = await fetch(\n        `https://ai-brief-api-${session.apiEnv}/api/brands/v1/organizations/${session.orgId}/briefs/${briefId}/sections/${id}`,\n        {\n          method: \"PATCH\",\n          body: JSON.stringify(\n            pick({ ...section, name }, [\"deletable\", \"name\", \"order\"])\n          ),\n          headers: {\n            \"Content-Type\": \"application/json\",\n            ...(session?.token\n              ? { Authorization: `Bearer ${session?.token}` }\n              : {}),\n          },\n        }\n      )\n\n      if (!patchSectionRes.ok) {\n        throw patchSectionRes\n      }\n\n      await handleGetBriefVersions()\n    } catch (error: unknown) {\n      const { detail } = error as HTTPValidationError\n      toast.error(detail[0]?.msg)\n    } finally {\n      setIsActionPending(false)\n    }\n  }\n\n  const handleCopyTextOnClick = (): void => {\n    const text = artifactContentRef?.current?.sections?.reduce(\n      (acc: string, cur: SectionProps, index: number) => {\n        if (index === 0) return \"\"\n\n        const fieldText =\n          cur?.fields?.reduce(\n            (acc: string, cur: ListBriefVersionSectionFieldsResponseModel) => {\n              const value = Array.isArray(cur.value)\n                ? cur.value\n                    .map((val) => (val as { name: string }).name)\n                    .join(\" \")\n                : (cur.value as string)\n              return acc.concat(cur.name, \"\\n\", value, \"\\n\")\n            },\n            \"\"\n          ) ?? \"\"\n\n        return acc.concat(cur.name, \"\\n\", fieldText, \"\\n\")\n      },\n      \"\"\n    )\n\n    copyToClipboard(text as string)\n  }\n\n  function handleExportBriefToDocx(markdownElement: HTMLDivElement): void {\n    const markdownText = htmlToMarkdown(markdownElement.innerHTML)\n    saveToDocx(markdownText, \"brief\")\n  }\n\n  return {\n    isActionPending,\n    versions,\n    artifactContentRef,\n    handleGetBriefVersions,\n    handleSetVersionOnSelect,\n    handleMainContentOnInput,\n    handleArtifactContentOnBlur,\n    handleCopyTextOnClick,\n    handleExportBriefToDocx,\n    handleArtifactContentNewVersion,\n  } as UseBriefLogicProps\n}\n",
      "type": "registry:hook",
      "target": "components/stream-components/blocks/chat/tools/brief/useBriefLogic.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/tools/brainstorming/Blog.tsx",
      "content": "import React, { useEffect, useMemo, useRef } from \"react\"\nimport { useAtomValue } from \"jotai\"\n\nimport { Button } from \"@/registry/new-york/ui/button\"\n\nimport { PreviewAside } from \"../../artifacts/PreviewAside\"\nimport EditCommands from \"../../EditCommands\"\nimport { Markdown } from \"../../Markdown\"\nimport { chatIdAtom, isLoadingAtom } from \"../../store/atoms\"\nimport { type ToolProps } from \"../../types\"\nimport { markdownToPlainText, replaceNewLines, saveToDocx } from \"../../utils\"\nimport { useBlogLogic } from \"./useBlogLogic\"\n\nexport function Blog({\n  messageId,\n  toolInvocation,\n}: ToolProps): React.ReactNode {\n  const { args } = toolInvocation\n  const mainContent = useMemo(\n    () => args?.result?.output ?? {},\n    [args?.result?.output]\n  )\n\n  /* IDs */\n  const brainstormId = args?.data?.id\n\n  /* Hooks */\n  const {\n    isActionPending,\n    versions,\n    artifactContentRef,\n    setUnSavedArtifactContent,\n    handleGetBrainstorm,\n    handleCopyTextOnClick,\n    handleSetVersionOnSelect,\n    handleArtifactPanelOnClose,\n    handleMainContentOnInput,\n    handleOnSelectNewVersion,\n    quickActions,\n  } = useBlogLogic()\n  const mounted = useRef<boolean>(false)\n\n  /* Atoms */\n  const isLoading = useAtomValue(isLoadingAtom)\n  const chatId = useAtomValue(chatIdAtom)\n\n  /* Flags */\n  const isMainContentAvailable = !!mainContent?.length\n  const canRender =\n    !!chatId?.length && !mounted.current && isMainContentAvailable\n  const hasLatestData = !isLoading && brainstormId && messageId\n\n  /* Effects */\n  /* Init */\n  useEffect(() => {\n    if (canRender) {\n      // Streaming\n      artifactContentRef.current = replaceNewLines(mainContent)\n      setUnSavedArtifactContent(replaceNewLines(mainContent))\n\n      /* Get the latest version if using chat history */\n      if (hasLatestData) {\n        // History\n        mounted.current = true\n        artifactContentRef.current = replaceNewLines(mainContent)\n        handleGetBrainstorm(brainstormId)\n      }\n    }\n  }, [\n    artifactContentRef,\n    brainstormId,\n    canRender,\n    handleGetBrainstorm,\n    hasLatestData,\n    mainContent,\n    setUnSavedArtifactContent,\n  ])\n\n  return (\n    <section className=\"flex flex-col space-y-5\">\n      <PreviewAside\n        id=\"blog\"\n        versions={versions}\n        buttonTitle={markdownToPlainText(replaceNewLines(mainContent)).slice(\n          0,\n          100\n        )}\n        isActionPending={isActionPending}\n        onSelectVersion={(value) =>\n          handleSetVersionOnSelect(brainstormId, value)\n        }\n        onSelectNewVersion={handleOnSelectNewVersion}\n        onClose={() => handleArtifactPanelOnClose(brainstormId)}\n        footerContent={{\n          start: <>{quickActions(chatId, messageId, brainstormId)}</>,\n          end: (\n            <>\n              <EditCommands>\n                <EditCommands.Copy\n                  onClick={handleCopyTextOnClick}\n                ></EditCommands.Copy>\n              </EditCommands>\n              <Button\n                onClick={() => saveToDocx(artifactContentRef.current, \"blog\")}\n              >\n                Export\n              </Button>\n            </>\n          ),\n        }}\n      >\n        {isMainContentAvailable && (\n          <div\n            className=\"stream-chat-editable\"\n            contentEditable={!isActionPending}\n            suppressContentEditableWarning\n            onInput={handleMainContentOnInput}\n          >\n            <Markdown id=\"blog\" text={artifactContentRef.current} />\n          </div>\n        )}\n      </PreviewAside>\n    </section>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/tools/brainstorming/Blog.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/tools/brainstorming/utils.tsx",
      "content": "import React from \"react\"\nimport { mdiCheckboxMarkedCircleOutline } from \"@mdi/js\"\nimport {\n  documents,\n  type ChunkModelV2,\n  type ListChunksModelResponseV2,\n} from \"@sitecore/stream-ui-core\"\nimport { pick } from \"lodash\"\n\nimport { Markdown } from \"../../Markdown\"\nimport { MessageSubtitle } from \"../../MessageSubtitle\"\nimport { type Source } from \"../../types\"\nimport {\n  extractBrandkitSourcesFromWorkflow,\n  firstCharToUpperCase,\n  removeDuplicatesFromArray,\n  TOOLS_SOURCES_TITLES,\n} from \"../../utils\"\nimport {\n  type SearchContentProps,\n  type WorkflowBrandkitSection,\n  type WorkflowItem,\n} from \"../../Workflow\"\nimport { Sources } from \"../Sources\"\n\nexport interface WorkflowBrandkitSectionItemsProps {\n  workflow: WorkflowItem[]\n  organizationId: string\n}\n\nexport function withIsLoading(\n  items: WorkflowItem[] = [],\n  isLoading: boolean = false\n): WorkflowItem[] {\n  return items.map((item: WorkflowItem) => {\n    return { ...item, isLoading }\n  })\n}\n\nexport function withUpdatedSearchItems(\n  items: WorkflowItem[] = []\n): WorkflowItem[] {\n  return items.map((item: WorkflowItem) => {\n    if (item.name === \"search\") {\n      return workflowRenderSearchItems(item)\n    }\n    return item\n  })\n}\n\nfunction workflowRenderSearchItems(item: WorkflowItem): WorkflowItem {\n  return !Array.isArray(item.content) // Content could be a string\n    ? item\n    : {\n        ...item,\n        content: (item.content as SearchContentProps[]).map(\n          (cont, index: number) => {\n            const keys = Object.keys(cont) as (keyof SearchContentProps)[]\n\n            return keys.map((key, idx: number) => {\n              const sources =\n                key === \"web_search\"\n                  ? (cont[key]?.reduce((acc, cur): Source[] => {\n                      return [...acc, ...(cur?.sources ?? [])]\n                    }, [] as Source[]) ?? [])\n                  : cont[key]\n\n              return (\n                <div\n                  key={`${key}_${index}_${idx}`}\n                  className=\"mb-4 flex flex-col\"\n                >\n                  {key === \"question\" ? (\n                    <div className=\"flex flex-col space-y-2\">\n                      <h3 className=\"text-2xl font-semibold\">\n                        {firstCharToUpperCase(key)}\n                      </h3>\n                      <p className=\"text-[16px]\">{cont[key]}</p>\n                    </div>\n                  ) : (\n                    <div className=\"flex flex-col space-y-2\">\n                      <h4 className=\"text-lg font-semibold\">\n                        {TOOLS_SOURCES_TITLES[\n                          key as keyof typeof TOOLS_SOURCES_TITLES\n                        ] ?? key}\n                      </h4>\n                      <Sources sources={sources as Source[]} />\n                    </div>\n                  )}\n                </div>\n              )\n            })\n          }\n        ),\n      }\n}\n\nexport async function getWorkflowRenderBrandkitSectionItemsSources({\n  workflow,\n  organizationId,\n}: WorkflowBrandkitSectionItemsProps): Promise<unknown[]> {\n  return Promise.all(\n    workflow.map(async (item: WorkflowItem) => {\n      return await new Promise(async (resolve) => {\n        if (item.data?.brandkitSections) {\n          // Merge all fields from all sections\n          const fields =\n            item?.data?.brandkitSections.reduce(\n              (acc: string[], cur: WorkflowBrandkitSection) => {\n                return [...acc, ...cur.fields]\n              },\n              [] as string[]\n            ) ?? []\n\n          // Get chunks for every id\n          const brandkitSections = (\n            await Promise.allSettled(\n              fields.map(async (fieldId) => {\n                return await documents.listChunksV2ApiDocumentsV2OrganizationsOrganizationIdChunksGet(\n                  {\n                    path: {\n                      organizationId,\n                    },\n                    query: {\n                      pageNumber: 1,\n                      referenceId: fieldId,\n                      referenceType: \"brandkitField\",\n                    },\n                  }\n                )\n              })\n            )\n          )\n            .filter((res) => res.status === \"fulfilled\")\n            .map((item) => item.value)\n\n          // Get images from chunks\n          const sourcesImages: (Source & ChunkModelV2)[] =\n            removeDuplicatesFromArray(\n              (brandkitSections\n                ?.map(\n                  (section) =>\n                    (section as unknown as ListChunksModelResponseV2).data ?? []\n                )\n                .flat()\n                .map((source) => ({\n                  ...source,\n                  type: \"image\",\n                  url: source.imageUrl,\n                })) as unknown as (Source & ChunkModelV2)[]) ?? [],\n              \"url\"\n            )\n\n          // Properties with the parent_ prefix are our PDFs. They are possible duplicates that we clear here\n          const sourcesPdfs: Source[] = removeDuplicatesFromArray(\n            sourcesImages\n              .filter((source: ChunkModelV2) => !!source?.parent_url?.length)\n              .map((source) => pick(source, [\"parent_title\", \"parent_url\"]))\n              .map((source) => ({\n                ...source,\n                type: \"pdf\",\n                url: source.parent_url,\n                title: source.parent_title,\n              })) as unknown as Source[],\n            \"url\"\n          )\n\n          const sources = [...sourcesImages, ...sourcesPdfs]\n\n          extractBrandkitSourcesFromWorkflow[\"Brand Kit section sources\"] =\n            removeDuplicatesFromArray(\n              [\n                ...extractBrandkitSourcesFromWorkflow[\n                  \"Brand Kit section sources\"\n                ],\n                ...sourcesPdfs,\n              ],\n              \"url\"\n            )\n\n          const content = sources?.length ? (\n            <div className=\"mt-4 flex flex-col space-y-2\">\n              <MessageSubtitle\n                icon={mdiCheckboxMarkedCircleOutline}\n                title=\"Used brand kit sections\"\n              />\n              <Sources sources={sources} />\n            </div>\n          ) : null\n\n          resolve({\n            ...item,\n            content: (\n              <>\n                {typeof item.content === \"string\" ? (\n                  <Markdown text={item.content} />\n                ) : (\n                  item.content\n                )}\n                {content}\n              </>\n            ),\n          })\n        }\n        resolve(item)\n      })\n    })\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/tools/brainstorming/utils.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/tools/brainstorming/useBlogLogic.tsx",
      "content": "import React, { useCallback, useRef, useState, type FormEvent } from \"react\"\nimport {\n  mdiMagicStaff,\n  mdiReload,\n  mdiStarFourPoints,\n  mdiStop,\n  mdiText,\n  mdiTextLong,\n} from \"@mdi/js\"\nimport {\n  abTesting,\n  brainstorming,\n  HTTPError,\n  type AbRecommendations,\n} from \"@sitecore/stream-ui-core\"\nimport { useSetAtom } from \"jotai\"\nimport { omit } from \"lodash\"\nimport { toast } from \"sonner\"\n\nimport { Button } from \"@/registry/new-york/ui/button\"\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/registry/new-york/ui/popover\"\n\nimport {\n  setPreviewAsideMaxVersions,\n  type PreviewAsideVersions,\n} from \"../../artifacts/PreviewAside\"\nimport { useChatProvider } from \"../../hooks/useChatProvider\"\nimport { Icon } from \"../../Icon\"\nimport { apiQueueAtom } from \"../../store/atoms\"\nimport { type HTTPValidationError } from \"../../types\"\nimport {\n  copyToClipboard,\n  htmlToMarkdown,\n  markdownToPlainText,\n  STRIP_TEXT_REGEX,\n} from \"../../utils\"\nimport { ReferencesBuilder } from \"../../utils/referencesBuilder\"\n\nexport type QuickActionOptionsProps = {\n  icon: React.ReactNode\n  description: string\n  predefinedPrompt: AbRecommendations[\"predefinedPrompt\"]\n}[]\n\nconst quickActionOptions: QuickActionOptionsProps = [\n  {\n    icon: <Icon aiGradient=\"400\" path={mdiTextLong} />,\n    description: \"Make Longer\",\n    predefinedPrompt: 40,\n  },\n  {\n    icon: <Icon aiGradient=\"400\" path={mdiText} />,\n    description: \"Make Shorter\",\n    predefinedPrompt: 30,\n  },\n  {\n    icon: <Icon aiGradient=\"400\" path={mdiMagicStaff} />,\n    description: \"Simplify\",\n    predefinedPrompt: 62,\n  },\n  {\n    icon: <Icon aiGradient=\"400\" path={mdiReload} />,\n    description: \"Rephrase\",\n    predefinedPrompt: 10,\n  },\n]\n\nexport interface UseBlogLogicProps {\n  isActionPending: boolean\n  versions: PreviewAsideVersions\n  artifactContentRef: React.MutableRefObject<string>\n  isPopoverOpen: boolean\n  isQuickActionLoading: boolean\n  setIsQuickActionLoading: React.Dispatch<React.SetStateAction<boolean>>\n  setIsPopoverOpen: React.Dispatch<React.SetStateAction<boolean>>\n  setUnSavedArtifactContent: React.Dispatch<React.SetStateAction<string>>\n  handleGetBrainstorm: (brainstormId: string) => Promise<void>\n  handlePatchBrainstorm: (\n    brainstormId: string,\n    patchData: string\n  ) => Promise<void>\n  handleSetVersionOnSelect: (\n    brainstormId: string,\n    versionNumber: string\n  ) => Promise<void>\n  handleMainContentOnInput: (e: FormEvent<HTMLDivElement>) => void\n  handleCopyTextOnClick: () => void\n  handleArtifactPanelOnClose: (brainstormId: string) => Promise<void>\n  handleQuickActionOnSelect: (\n    predefinedPrompt: AbRecommendations[\"predefinedPrompt\"],\n    chatId: string,\n    messageId: string,\n    brainstormId: string\n  ) => Promise<void>\n  handleStopQuickAction: () => Promise<void>\n  handleOnSelectNewVersion: () => Promise<void>\n  quickActions: (\n    chatId: string,\n    messageId: string,\n    brainstormId: string\n  ) => React.ReactNode\n}\n\nexport function useBlogLogic(): UseBlogLogicProps {\n  /* Hooks */\n  const { session } = useChatProvider()\n  const [versions, setVersions] = useState<PreviewAsideVersions>({\n    selected: \"\",\n    available: [],\n  })\n  const [unSavedArtifactContent, setUnSavedArtifactContent] =\n    useState<string>(\"\")\n  const [isActionPending, setIsActionPending] = useState(false)\n  const [isPopoverOpen, setIsPopoverOpen] = useState(false)\n  const [isQuickActionLoading, setIsQuickActionLoading] = useState(false)\n  const artifactContentRef = useRef<string>(\"\")\n  const [abortController, setAbortController] =\n    useState<AbortController | null>(null)\n\n  /* Atoms */\n  const setApiQueue = useSetAtom(apiQueueAtom)\n\n  async function handleGetBrainstorm(brainstormId: string): Promise<void> {\n    setIsActionPending(true)\n    setApiQueue((prev) => ({ ...prev, getBrainstorm: brainstormId }))\n\n    try {\n      const { data } =\n        await brainstorming.getBrainstormApiBrainstormsV1BrainstormsBrainstormIdGet(\n          {\n            path: {\n              brainstormId,\n            },\n          }\n        )\n\n      artifactContentRef.current = data?.output ?? \"\"\n      setVersions({\n        selected: String(data?.version),\n        available: setPreviewAsideMaxVersions(String(data?.version)),\n      })\n      setUnSavedArtifactContent(data?.output ?? \"\")\n    } catch (error: unknown) {\n      const { response } = error as HTTPError\n      toast.error(response.statusText)\n    } finally {\n      setIsActionPending(false)\n      setApiQueue((prev) => omit(prev, [\"getBrainstorm\"]))\n    }\n  }\n\n  const handlePatchBrainstorm = useCallback(\n    async function (brainstormId: string, patchData: string): Promise<void> {\n      setIsActionPending(true)\n\n      try {\n        const patchBrainstormRes = await fetch(\n          `https://ai-brainstorming-api-${session.apiEnv}/api/brainstorms/v1/brainstorms/${brainstormId}`,\n          {\n            method: \"PATCH\",\n            body: JSON.stringify({\n              output: patchData,\n            }),\n            headers: {\n              \"Content-Type\": \"application/json\",\n              ...(session?.token\n                ? { Authorization: `Bearer ${session?.token}` }\n                : {}),\n            },\n          }\n        )\n\n        if (!patchBrainstormRes.ok) {\n          throw patchBrainstormRes\n        }\n\n        const data = await patchBrainstormRes.json()\n\n        artifactContentRef.current = data?.output ?? \"\"\n        setVersions({\n          selected: String(data?.version),\n          available: setPreviewAsideMaxVersions(String(data?.version)),\n        })\n        setUnSavedArtifactContent(data?.output ?? \"\")\n      } catch (error: unknown) {\n        const { detail } = error as HTTPValidationError\n        toast.error(detail[0]?.msg)\n      } finally {\n        setIsActionPending(false)\n      }\n    },\n    [session.apiEnv, session?.token]\n  )\n\n  const handleQuickActionOnSelect = useCallback(\n    async function (\n      predefinedPrompt: AbRecommendations[\"predefinedPrompt\"],\n      chatId: string,\n      messageId: string,\n      brainstormId: string\n    ): Promise<void> {\n      setIsPopoverOpen(false)\n      setIsQuickActionLoading(true)\n      setIsActionPending(true)\n\n      const references = ReferencesBuilder({\n        orgId: session.orgId,\n        userId: session.userId,\n      })\n        .addChatMessage({ id: chatId, messageId })\n        .build()\n\n      try {\n        const { data } =\n          await abTesting.generateAbRecommendationsVariantsApiRecommendationsV2OrganizationsOrganizationIdVariantsPost(\n            {\n              body: {\n                fields: [\n                  {\n                    name: \"Quick Action\",\n                    value: artifactContentRef.current,\n                  },\n                ],\n                predefinedPrompt,\n                numberOfVariants: 1,\n                references: references as never,\n              },\n              path: {\n                organizationId: session.orgId,\n              },\n            }\n          )\n\n        handlePatchBrainstorm(\n          brainstormId,\n          data?.variants?.[0].fields?.[0].value ?? \"\"\n        )\n      } catch (error: unknown) {\n        const { response } = error as HTTPError\n        toast.error(response.statusText)\n      } finally {\n        setIsActionPending(false)\n        setIsQuickActionLoading(false)\n        setAbortController(null)\n      }\n    },\n    [handlePatchBrainstorm, session.orgId, session.userId]\n  )\n\n  async function handleStopQuickAction(): Promise<void> {\n    if (abortController) {\n      abortController.abort()\n      setAbortController(null)\n      setIsQuickActionLoading(false)\n    }\n  }\n\n  async function handleSetVersionOnSelect(\n    brainstormId: string,\n    versionNumber: string\n  ): Promise<void> {\n    setVersions((prev) => ({ ...prev, selected: versionNumber }))\n    setIsActionPending(true)\n\n    try {\n      const { data } =\n        await brainstorming.getBrainstormApiBrainstormsV1BrainstormsBrainstormIdVersionsVersionNumberGet(\n          {\n            path: {\n              brainstormId,\n              versionNumber,\n            },\n          }\n        )\n\n      artifactContentRef.current = data?.output ?? \"\"\n      setUnSavedArtifactContent(data?.output ?? \"\")\n    } catch (error: unknown) {\n      const { response } = error as HTTPError\n      toast.error(response.statusText)\n    } finally {\n      setIsActionPending(false)\n    }\n  }\n\n  async function handleOnSelectNewVersion(): Promise<void> {}\n\n  async function handleArtifactPanelOnClose(\n    brainstormId: string\n  ): Promise<void> {\n    if (\n      unSavedArtifactContent?.replace(STRIP_TEXT_REGEX, \"\") !==\n      artifactContentRef.current?.replace(STRIP_TEXT_REGEX, \"\")\n    ) {\n      await handlePatchBrainstorm(brainstormId, artifactContentRef.current)\n    }\n  }\n\n  function handleMainContentOnInput(e: FormEvent<HTMLDivElement>): void {\n    const parent = e.target as HTMLDivElement\n    artifactContentRef.current = htmlToMarkdown(String(parent?.innerHTML))\n  }\n\n  function handleCopyTextOnClick(): void {\n    copyToClipboard(markdownToPlainText(artifactContentRef.current))\n  }\n\n  function quickActions(\n    chatId: string,\n    messageId: string,\n    brainstormId: string\n  ): React.ReactNode {\n    return isQuickActionLoading ? (\n      <Button\n        data-testid={`blog_quick_actions_stop_generation`}\n        variant={\"ghost\"}\n        colorScheme=\"neutral\"\n        onClick={handleStopQuickAction}\n      >\n        <Icon path={mdiStop} className=\"animate-pulse\" />\n        <span className=\"ml-2 flex items-center\">\n          Generating\n          <span className=\"ml-1 animate-pulse\">...</span>\n        </span>\n      </Button>\n    ) : (\n      <Popover open={isPopoverOpen} onOpenChange={setIsPopoverOpen}>\n        <PopoverTrigger asChild>\n          <Button\n            data-testid={`blog_quick_actions_button}`}\n            variant={\"ghost\"}\n            colorScheme=\"neutral\"\n            disabled={isActionPending || isQuickActionLoading}\n          >\n            <Icon path={mdiStarFourPoints} /> Quick Actions\n          </Button>\n        </PopoverTrigger>\n        <PopoverContent\n          className=\"flex w-min flex-col items-start space-y-2\"\n          sideOffset={16}\n          align=\"start\"\n        >\n          {quickActionOptions.map((option, index) => (\n            <Button\n              data-testid={`blog_quick_actions_select_${index}`}\n              key={option.description}\n              variant={\"ghost\"}\n              onClick={() =>\n                handleQuickActionOnSelect(\n                  option.predefinedPrompt,\n                  chatId,\n                  messageId,\n                  brainstormId\n                )\n              }\n            >\n              {option.icon}\n              <span className=\"text-md text-blackAlpha-900 font-normal\">\n                {option.description}\n              </span>\n            </Button>\n          ))}\n        </PopoverContent>\n      </Popover>\n    )\n  }\n\n  return {\n    isActionPending,\n    versions,\n    artifactContentRef,\n    isPopoverOpen,\n    isQuickActionLoading,\n    setIsQuickActionLoading,\n    setIsPopoverOpen,\n    setUnSavedArtifactContent,\n    handleGetBrainstorm,\n    handlePatchBrainstorm,\n    handleSetVersionOnSelect,\n    handleMainContentOnInput,\n    handleCopyTextOnClick,\n    handleArtifactPanelOnClose,\n    handleQuickActionOnSelect,\n    handleStopQuickAction,\n    handleOnSelectNewVersion,\n    quickActions,\n  }\n}\n",
      "type": "registry:hook",
      "target": "components/stream-components/blocks/chat/tools/brainstorming/useBlogLogic.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/tools/brainstorming/Brainstorming.tsx",
      "content": "import React, { useCallback, useEffect, useRef } from \"react\"\nimport { useAtomValue, useSetAtom } from \"jotai\"\nimport { isEmpty } from \"lodash\"\n\nimport { Reveal } from \"../../artifacts/Reveal\"\nimport { useChatProvider } from \"../../hooks/useChatProvider\"\nimport {\n  chatIdAtom,\n  extractSourcesFromDataAtom,\n  isLoadingAtom,\n  isMessageAlreadyGeneratedAtom,\n} from \"../../store/atoms\"\nimport { type ToolProps } from \"../../types\"\nimport { extractBrandkitSourcesFromWorkflow } from \"../../utils\"\nimport { Workflow, type WorkflowItem } from \"../../Workflow\"\nimport { Tool } from \"../Tool\"\nimport { Blog } from \"./Blog\"\nimport {\n  getWorkflowRenderBrandkitSectionItemsSources,\n  withIsLoading,\n  withUpdatedSearchItems,\n} from \"./utils\"\n\nexport function Brainstorming(props: ToolProps): React.ReactNode {\n  const {\n    messageId,\n    toolInvocation: { args },\n  } = props\n\n  /* IDs */\n  const brainstormId = args?.data?.id\n\n  /* Hooks */\n  const { session } = useChatProvider()\n  const mounted = useRef<boolean>(false)\n  const workflowItems = useRef<WorkflowItem[]>([])\n\n  /* Atoms */\n  const isMessageAlreadyGenerated = useAtomValue(isMessageAlreadyGeneratedAtom)(\n    messageId\n  )\n  const isLoading = useAtomValue(isLoadingAtom)\n  const setExtractSourcesFromData = useSetAtom(extractSourcesFromDataAtom)\n  const chatId = useAtomValue(chatIdAtom)\n\n  /* Computed */\n  const isWorkflowAvailable = !!args?.result?.workflow?.length\n  const isBlogAvailable = !!args?.result?.output?.length\n  const canRender =\n    !!chatId.length && !mounted.current && !isEmpty(args?.result)\n  const hasLatestData = !isLoading && brainstormId && messageId\n\n  const handleAddBrandkitSectionsSourcesToWorkflow = useCallback(async () => {\n    const updatedWorkflowItems =\n      await getWorkflowRenderBrandkitSectionItemsSources({\n        workflow: workflowItems.current,\n        organizationId: session.orgId,\n      })\n    // Chat might have more than one brainstorming; therefore, we need to ID the sources\n    setExtractSourcesFromData((prev) => ({\n      ...prev,\n      [messageId]: extractBrandkitSourcesFromWorkflow,\n    }))\n    workflowItems.current = updatedWorkflowItems as WorkflowItem[]\n  }, [messageId, session.orgId, setExtractSourcesFromData])\n\n  useEffect(() => {\n    if (canRender) {\n      // Streaming\n      workflowItems.current = withUpdatedSearchItems(\n        withIsLoading(args?.result?.workflow, isLoading)\n      )\n\n      if (hasLatestData) {\n        mounted.current = true\n        workflowItems.current = withUpdatedSearchItems(\n          withIsLoading(args?.result?.workflow, isLoading)\n        )\n        handleAddBrandkitSectionsSourcesToWorkflow()\n      }\n    }\n  }, [\n    args?.result?.workflow,\n    canRender,\n    handleAddBrandkitSectionsSourcesToWorkflow,\n    hasLatestData,\n    isLoading,\n  ])\n\n  return (\n    <>\n      {isWorkflowAvailable && (\n        <Reveal\n          isGenerating={isMessageAlreadyGenerated}\n          titleStreamStart=\"Thinking\"\n          titleStreamEnd=\"Thinking\"\n          id=\"brainstorming_tools\"\n          isExpandable\n        >\n          <Tool className=\"rounded-lg border border-[#F7F7F7] bg-white p-2 py-3\">\n            <Workflow items={workflowItems.current} />\n          </Tool>\n        </Reveal>\n      )}\n      {isBlogAvailable && <Blog {...props} />}\n    </>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/tools/brainstorming/Brainstorming.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/stream-chat-history/chat-history.tsx",
      "content": "\"use client\"\n\nimport { useCallback, useEffect, useState } from \"react\"\nimport { mdiChatOutline, mdiTrashCanOutline } from \"@mdi/js\"\nimport { chat as chatApi, HTTPError } from \"@sitecore/stream-ui-core\"\nimport { useSetAtom } from \"jotai\"\nimport { omit } from \"lodash\"\nimport { flushSync } from \"react-dom\"\nimport { toast } from \"sonner\"\n\nimport { Button } from \"@/registry/new-york/ui/button\"\nimport {\n  Dialog,\n  DialogContent,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from \"@/registry/new-york/ui/dialog\"\n\nimport { useGetChats } from \"../../hooks/use-get-chats\"\nimport { cn } from \"../../lib/utils\"\nimport { useChatProvider } from \"../chat/hooks/useChatProvider\"\nimport { Icon } from \"../chat/Icon\"\nimport { apiQueueAtom } from \"../chat/store/atoms\"\n\ninterface ChatItem {\n  id: string\n  title: string\n  disabled: boolean\n}\n\nexport type ChatHistoryProps = {\n  className?: string\n  onChatClick?: (chat: ChatItem) => void\n  onChatDelete?: (chat: ChatItem) => void\n  disabled?: boolean\n  refetch?: boolean\n}\n\n/**\n * Renders a chat history list with clickable chat items and delete buttons.\n *\n * @param {Object} props The properties for the ChatHistory component.\n * @param {string} props.className Optional additional class names for the container.\n * @param {Array} props.chats An array of chat objects to be displayed. Each chat object should include `id`, `title`, and `disabled` properties.\n * @param {Function} [props.onChatClick] A callback function invoked when a chat item is clicked. Receives the clicked chat object as a parameter.\n * @param {Function} [props.onChatDelete] A callback function invoked when the delete button for a chat is clicked. Receives the chat object to be deleted as a parameter.\n * @return {JSX.Element} The rendered ChatHistory component.\n */\nexport function ChatHistory(props: ChatHistoryProps) {\n  const { className, onChatClick, onChatDelete, disabled, refetch } = props\n\n  /* Hooks */\n  const { session } = useChatProvider()\n  const [deletedChat, setDeletedChat] = useState<ChatItem | null>(null)\n  const [isDeleting, setIsDeleting] = useState(false)\n  const [isDeleteChatModalOpen, setIsDeleteChatModalOpen] = useState(false)\n  const getChats = useGetChats(session.orgId, session.userId)\n  const [_chats, setChats] = useState<ChatItem[]>([])\n\n  /* Atoms */\n  const setApiQueue = useSetAtom(apiQueueAtom)\n\n  async function handleDeleteChatOnDelete(chat: ChatItem) {\n    setIsDeleting(true)\n    setApiQueue((prev) => ({ ...prev, [`removeChat_${chat?.id}`]: chat?.id }))\n\n    try {\n      await chatApi.deleteUserChatApiChatsV1OrganizationsOrganizationIdUsersUserIdChatsChatIdDelete(\n        {\n          path: {\n            userId: session.userId,\n            chatId: chat.id,\n            organizationId: session.orgId,\n          },\n        }\n      )\n\n      setDeletedChat(null)\n      setIsDeleteChatModalOpen(false)\n      flushSync(() => {\n        onChatDelete?.(chat)\n      })\n\n      toast.success(\"Chat deleted successfully\")\n\n      await fetchChats()\n    } catch (error: unknown) {\n      const { response } = error as HTTPError\n      const { detail } = (await response.json()) as {\n        type: string\n        detail: string\n      }\n      toast.error(detail)\n    } finally {\n      setIsDeleting(false)\n      setApiQueue((prev) => omit(prev, [`removeChat_${chat?.id}`]))\n    }\n  }\n\n  const fetchChats = useCallback(\n    async function () {\n      try {\n        const data = await getChats()\n        setChats(data as unknown as ChatItem[])\n      } catch (error: unknown) {\n        const { response } = error as HTTPError\n        const { detail } = (await response.json()) as {\n          type: string\n          detail: string\n        }\n        toast.error(detail)\n      }\n    },\n    [getChats]\n  )\n\n  /* Init */\n  useEffect(() => {\n    fetchChats()\n  }, [fetchChats])\n\n  useEffect(() => {\n    if (refetch) fetchChats()\n  }, [fetchChats, refetch])\n\n  return (\n    <div className={cn(\"flex w-64 flex-col gap-1\", className)}>\n      {_chats\n        ?.map((chat) => ({ ...chat, disabled }) as ChatItem)\n        .map((chat) => (\n          <div\n            key={chat.id}\n            aria-disabled={chat.disabled}\n            className={cn(\n              \"group flex min-h-10 items-center justify-between gap-2 rounded px-2 py-1 transition-colors\",\n              {\n                \"cursor-pointer hover:bg-purple-100\": !chat.disabled,\n                \"cursor-not-allowed opacity-50\": chat.disabled,\n              }\n            )}\n            onClick={() => {\n              if (chat.disabled) return\n              onChatClick?.(chat)\n            }}\n          >\n            <div className=\"flex min-w-0 items-center gap-2\">\n              <Icon path={mdiChatOutline} className=\"size-6 text-gray-500\" />\n              <h2 className=\"text-md min-w-0 truncate\">{chat.title}</h2>\n            </div>\n            <button\n              disabled={chat.disabled}\n              className={cn(\"hidden\", {\n                \"cursor-pointer group-hover:block\": !chat.disabled,\n                \"cursor-not-allowed\": chat.disabled,\n              })}\n              onClick={(e) => {\n                e.stopPropagation()\n                if (chat.disabled) return\n                setDeletedChat(chat)\n                setIsDeleteChatModalOpen(true)\n              }}\n            >\n              <Icon\n                path={mdiTrashCanOutline}\n                className=\"size-8 rounded-full p-1 text-gray-500 hover:bg-purple-300\"\n              />\n            </button>\n          </div>\n        ))}\n      <Dialog\n        open={isDeleteChatModalOpen}\n        onOpenChange={setIsDeleteChatModalOpen}\n      >\n        <DialogContent>\n          <DialogHeader>\n            <DialogTitle className=\"body-text text-xl\">Delete Chat</DialogTitle>\n          </DialogHeader>\n          <p className=\"text-md py-5 font-normal\">\n            Are you sure you want to delete this chat? This action cannot be\n            undone.\n          </p>\n          <DialogFooter>\n            <Button\n              variant=\"ghost\"\n              colorScheme=\"neutral\"\n              onClick={() => {\n                setDeletedChat(null)\n                setIsDeleteChatModalOpen(false)\n              }}\n            >\n              Cancel\n            </Button>\n            <Button\n              disabled={isDeleting}\n              colorScheme=\"danger\"\n              onClick={() => handleDeleteChatOnDelete(deletedChat as ChatItem)}\n            >\n              Delete\n            </Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n    </div>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/stream-chat-history/chat-history.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/artifacts/PreviewAside.tsx",
      "content": "import React, {\n  useEffect,\n  useId,\n  useRef,\n  type ReactNode,\n  type SyntheticEvent,\n} from \"react\"\nimport { mdiArrowExpand, mdiClose } from \"@mdi/js\"\nimport { useAtom, useAtomValue } from \"jotai\"\nimport { createPortal } from \"react-dom\"\n\nimport { Button } from \"@/registry/new-york/ui/button\"\nimport {\n  Card,\n  CardContent,\n  CardFooter,\n  CardHeader,\n  CardTitle,\n} from \"@/registry/new-york/ui/card\"\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/registry/new-york/ui/select\"\n\nimport { cn } from \"../../../lib/utils\"\nimport { Icon } from \"../Icon\"\nimport { RectangleStar } from \"../icons/RectangleStar\"\nimport { Spinner } from \"../Spinner\"\nimport { artifactsAtom, chatIdAtom, isLoadingAtom } from \"../store/atoms\"\nimport { firstCharToUpperCase } from \"../utils\"\n\nexport interface PreviewAsideVersions {\n  selected: string\n  available: string[]\n}\n\nexport interface PreviewAsideProps {\n  id: string\n  children?: ReactNode | ReactNode[]\n  versions?: PreviewAsideVersions\n  buttonTitle?: string\n  asideTitle?: string\n  isActionPending?: boolean\n  isPreview?: boolean\n  onSelectVersion?: (value: string) => void\n  onOpen?: (e?: SyntheticEvent<HTMLDivElement>) => void\n  onClose?: (e?: SyntheticEvent<HTMLButtonElement>) => void\n  onSelectNewVersion?: () => void\n  footerContent?: {\n    start?: ReactNode | ReactNode[]\n    end?: ReactNode | ReactNode[]\n  }\n}\n\nexport function setPreviewAsideMaxVersions(\n  ver: string,\n  maxAllowedNumberOfVersions: number = 10\n): string[] {\n  const maxVersions: string[] = []\n  const version = Number(ver)\n\n  for (\n    let i = Math.max(1, version - maxAllowedNumberOfVersions + 1);\n    i <= version;\n    i++\n  ) {\n    maxVersions.push(String(i))\n  }\n  return maxVersions\n}\n\nexport function PreviewAside({\n  children,\n  id,\n  isActionPending,\n  versions,\n  buttonTitle = \"\",\n  asideTitle = \"\",\n  isPreview,\n  onSelectVersion,\n  onSelectNewVersion,\n  onOpen,\n  onClose,\n  footerContent = {},\n}: PreviewAsideProps): React.ReactNode {\n  const { start, end } = footerContent\n\n  /* Hooks */\n  const mounted = useRef<boolean>(false)\n  const artifactId = useId()\n\n  /* Atoms */\n  const isLoading = useAtomValue(isLoadingAtom)\n  const [artifacts, setArtifacts] = useAtom(artifactsAtom)\n  const chatId = useAtomValue(chatIdAtom)\n\n  /* Computed */\n  const areVersionsAvailable = !!versions?.available?.length\n  const portalPlaceHolder =\n    document.getElementById(\"artifactsPortalPlaceholder\") ?? ({} as HTMLElement)\n  const isPortalPlaceHolderAvailable = !!Object.keys(portalPlaceHolder).length\n  const isArtifactOpenWhileGenerating =\n    !mounted.current && chatId && isLoading && !(artifactId in artifacts)\n  const _isPreview = isPreview ?? !artifacts?.[artifactId]?.open\n\n  /* Keep open if the last artifact to be rendered in the chat */\n  useEffect(() => {\n    if (isArtifactOpenWhileGenerating) {\n      setArtifacts({ [artifactId]: { open: true } })\n    }\n  }, [artifactId, isArtifactOpenWhileGenerating, setArtifacts])\n\n  /* Events */\n  function handleOpenOnClick(e: SyntheticEvent<HTMLDivElement>): void {\n    setArtifacts({ [artifactId]: { open: true } })\n    onOpen?.(e)\n  }\n\n  function handleVersionOnSelect(value: string): void {\n    if (value === \"new\") {\n      onSelectNewVersion?.()\n      return\n    }\n    onSelectVersion?.(value)\n  }\n\n  const handleCloseOnClick = (e: SyntheticEvent<HTMLButtonElement>): void => {\n    setArtifacts({ [artifactId]: { open: false } })\n    onClose?.(e)\n  }\n\n  const buttonPreviewAside = (\n    <div\n      data-testid={`preview_aside_${id}_${!_isPreview ? \"open\" : \"closed\"}`}\n      className=\"flex w-1/2 items-center rounded-lg border border-transparent bg-purple-200 p-3 text-purple-600\"\n    >\n      <RectangleStar fill=\"#5319E0\" />\n      <div className=\"ml-2 flex w-full justify-between\">\n        <span\n          className=\"line-clamp-2 flex text-left text-base font-semibold text-[#5319E0]\"\n          style={{\n            overflow: \"hidden\",\n            textOverflow: \"ellipsis\",\n            display: \"-webkit-box\",\n            WebkitLineClamp: 2,\n            WebkitBoxOrient: \"vertical\",\n          }}\n        >\n          {firstCharToUpperCase(buttonTitle)}\n        </span>\n        <span className=\"text-blackAlpha-500 flex items-center text-sm font-normal\">\n          {isActionPending ? (\n            <Spinner size=\"xs\" />\n          ) : (\n            areVersionsAvailable && <span>v{versions?.selected}</span>\n          )}\n        </span>\n      </div>\n    </div>\n  )\n\n  const asideContainer = (\n    <Card\n      data-testid={`preview_aside_${id}`}\n      className={cn(\n        \"border-blackAlpha-100 hover:border-blackAlpha-200 relative h-[175px] rounded-lg border bg-white px-5 py-2 transition-all\",\n        _isPreview\n          ? 'after:content-[\" \"] cursor-pointer after:absolute after:right-0 after:bottom-0 after:left-0 after:h-[50px] after:rounded-b-lg'\n          : \"h-full rounded-none border-none\",\n        (isLoading || isActionPending) &&\n          'after:content-[\" \"] after:pointer-events-auto after:absolute after:inset-0'\n      )}\n      onClick={_isPreview ? handleOpenOnClick : undefined}\n    >\n      <CardHeader className=\"flex flex-row justify-between space-y-0 p-0\">\n        <div\n          data-testid={`preview_aside_versions_${id}`}\n          className=\"flex items-center gap-2\"\n        >\n          <RectangleStar />\n          {!_isPreview && areVersionsAvailable && handleVersionOnSelect && (\n            <Select\n              data-testid={`preview_aside_version_select_${id}}`}\n              onValueChange={handleVersionOnSelect}\n              value={versions.selected}\n              disabled={_isPreview || isActionPending}\n            >\n              <SelectTrigger\n                data-testid={`preview_aside_version_trigger_${id}`}\n                className=\"text-neutral-fg text-md h-6 w-min gap-1 border-none px-1 font-semibold\"\n              >\n                <SelectValue />\n              </SelectTrigger>\n              <SelectContent>\n                {/*<div data-testid={`preview_aside_version_new_version`}>\n                  <SelectItem value=\"new\" className=\"cursor-pointer\">\n                    <Icon path={mdiPlus} /> New version\n                  </SelectItem>\n                </div>*/}\n                {versions.available.map((version: string, index: number) => (\n                  <div\n                    data-testid={`preview_aside_version_${index}`}\n                    key={`${version}_${index}`}\n                  >\n                    <SelectItem value={version} className=\"cursor-pointer\">\n                      v{version}\n                    </SelectItem>\n                  </div>\n                ))}\n              </SelectContent>\n            </Select>\n          )}\n          {isActionPending && <Spinner size=\"xs\" />}\n        </div>\n        <div className=\"flex items-center gap-2\">\n          {_isPreview && areVersionsAvailable && (\n            <span className=\"text-neutral-fg text-md h-6 w-min gap-1 border-none px-1 font-semibold\">\n              v{versions?.selected}\n            </span>\n          )}\n          <Button\n            data-testid={`preview_aside_close_button_${id}`}\n            variant={\"ghost\"}\n            colorScheme=\"neutral\"\n            size={\"icon\"}\n            onClick={!_isPreview ? handleCloseOnClick : undefined}\n          >\n            <Icon path={!_isPreview ? mdiClose : mdiArrowExpand} />\n          </Button>\n        </div>\n      </CardHeader>\n      <CardContent\n        className={cn(\"overflow-hidden px-0\", !_isPreview && \"overflow-y-auto\")}\n        data-testid=\"scroll-contain-artifact\"\n      >\n        <CardTitle className=\"pt-5 pb-3.5 text-lg font-semibold\">\n          {firstCharToUpperCase(asideTitle)}\n        </CardTitle>\n        <div className=\"relative mb-[125px]\">{children}</div>\n      </CardContent>\n      {!_isPreview && (\n        <CardFooter className=\"relative bottom-[105px] flex items-center justify-between bg-white px-0\">\n          <div className=\"flex items-center gap-4 self-start\">{start}</div>\n          <div className=\"flex items-center gap-4 self-end\">{end}</div>\n        </CardFooter>\n      )}\n    </Card>\n  )\n\n  return (\n    <>\n      {!_isPreview\n        ? isPortalPlaceHolderAvailable && (\n            <>\n              {buttonPreviewAside}\n              {createPortal(asideContainer, portalPlaceHolder)}\n            </>\n          )\n        : asideContainer}\n    </>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/artifacts/PreviewAside.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/artifacts/Reveal.tsx",
      "content": "import React, { useEffect, useRef, useState, type ReactNode } from \"react\"\nimport {\n  mdiArrowCollapseVertical,\n  mdiArrowExpandVertical,\n  mdiChevronUp,\n  mdiLoading,\n} from \"@mdi/js\"\n\nimport { Button } from \"@/registry/new-york/ui/button\"\n\nimport { cn } from \"../../../lib/utils\"\nimport { useAutoScroll } from \"../hooks/useAutoScroll\"\nimport { Icon } from \"../Icon\"\n\ninterface RevealSharedProps {\n  id: string\n  children?: ReactNode | ReactNode[]\n  isRevealed?: boolean\n  className?: string\n  isGenerating?: boolean\n  position?: \"left\" | \"right\"\n  isExpandable?: boolean\n}\n\ntype RevealTitleProps = RevealSharedProps & {\n  title?: string\n  titleStreamStart?: never\n  titleStreamEnd?: never\n}\n\ntype RevealStreamTitlesProps = RevealSharedProps & {\n  title?: never\n  titleStreamStart: string\n  titleStreamEnd: string\n}\n\nexport type RevealProps = RevealTitleProps | RevealStreamTitlesProps\n\nexport function Reveal({\n  id,\n  isRevealed,\n  position = \"left\",\n  title,\n  titleStreamStart = \"\",\n  titleStreamEnd,\n  children,\n  isExpandable = false,\n  isGenerating,\n  className = \"\",\n}: RevealProps): React.ReactNode {\n  /* Hooks */\n  const { contentRef, handleStopAutoScrollingOnScroll } =\n    useAutoScroll(children)\n  const [reveal, setReveal] = useState<boolean>(false)\n  const [expand, setExpand] = useState<boolean>(false)\n  const mounted = useRef(false)\n\n  /* Computed */\n  const isRevealing = isRevealed || reveal\n\n  function handleRevealOnClick(): void {\n    setReveal(!reveal)\n  }\n\n  function handleExpandOnClick(): void {\n    setExpand(!expand)\n  }\n\n  useEffect(\n    function () {\n      if (!mounted.current && isGenerating) {\n        setReveal(true)\n        mounted.current = true\n      }\n    },\n    [isGenerating]\n  )\n\n  return (\n    <section\n      data-testid={`thinking_reveal_${id}`}\n      className={cn(\n        \"bg-blackAlpha-50 relative mb-5 flex flex-col rounded-lg p-2 transition-all\",\n        className\n      )}\n    >\n      <header className=\"flex\">\n        <Button\n          data-testid={`thinking_reveal_${reveal ? \"close\" : \"open\"}_${id}`}\n          variant=\"link\"\n          className={cn(\n            \"text-md text-neutral-fg w-full flex-1 justify-start px-0 py-2 font-normal hover:no-underline\",\n            position === \"right\" && \"justify-end\"\n          )}\n          onClick={handleRevealOnClick}\n        >\n          {isGenerating && <Icon path={mdiLoading} className=\"animate-spin\" />}\n          {title ? title : isGenerating ? titleStreamStart : titleStreamEnd}\n          <Icon\n            path={mdiChevronUp}\n            className={cn(\n              \"rotate-0 transition-all duration-200\",\n              !isRevealing && \"rotate-180\"\n            )}\n          />\n        </Button>\n        {isRevealing && isExpandable && (\n          <Button\n            onClick={handleExpandOnClick}\n            data-testid={`thinking_reveal_${reveal ? \"close\" : \"open\"}_${id}`}\n            variant={\"ghost\"}\n            colorScheme=\"neutral\"\n            size={\"icon\"}\n            className=\"self-end\"\n          >\n            <Icon\n              path={!expand ? mdiArrowExpandVertical : mdiArrowCollapseVertical}\n            />\n          </Button>\n        )}\n      </header>\n      <div\n        data-testid={`reveal_content_${id}`}\n        ref={contentRef}\n        className={cn(\n          \"flex max-h-0 flex-col space-y-5 opacity-0 transition-all duration-300\",\n          isRevealing && \"mt-2 max-h-[450px] overflow-y-auto opacity-100\",\n          isRevealing && expand && \"max-h-full\"\n        )}\n        onWheel={handleStopAutoScrollingOnScroll}\n      >\n        {isRevealing && children}\n      </div>\n    </section>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/artifacts/Reveal.tsx"
    },
    {
      "path": "registry/new-york/stream/hooks/use-brandkit-by-id.ts",
      "content": "import { useCallback, useEffect, useMemo, useState } from \"react\"\nimport {\n  brandkitFromApiResponse,\n  brandkitToPlainObject,\n  brands,\n  getBrandkitDisplayName,\n  getBrandkitTagsByCategory,\n  hasBrandkitLogo,\n  // HTTP error types\n  HTTPError,\n  isDeletedBrandkit,\n  // Domain utilities\n  isDraftBrandkit,\n  isLockedBrandkit,\n  isPublishedBrandkit,\n  type Brandkit,\n  // HeyAPI generated types\n  type GetBrandKitApiBrandsV1OrganizationsOrganizationIdBrandkitsBrandkitIdGetData,\n  type GetBrandKitModelResponse,\n} from \"@sitecore/stream-ui-core\"\n\n// Hook options type - using HeyAPI generated types\nexport type UseBrandkitByIdOptions =\n  GetBrandKitApiBrandsV1OrganizationsOrganizationIdBrandkitsBrandkitIdGetData[\"path\"] &\n    (GetBrandKitApiBrandsV1OrganizationsOrganizationIdBrandkitsBrandkitIdGetData[\"query\"] extends undefined\n      ? object\n      : GetBrandKitApiBrandsV1OrganizationsOrganizationIdBrandkitsBrandkitIdGetData[\"query\"])\n\nexport interface UseBrandkitsByIdProps {\n  // Existing properties (unchanged)\n  isLoading: boolean\n  brandkit: Brandkit | null\n  error: Error | null\n  refetch: () => Promise<void>\n\n  // New computed properties\n  displayName: string | null\n  hasLogo: boolean\n  isDraft: boolean\n  isPublished: boolean\n  isDeleted: boolean\n  isLocked: boolean\n  tagCategories: string[]\n  referenceCount: number\n\n  // New utility functions\n  utils: {\n    getTagsByCategory: (category: string) => readonly string[]\n    hasTag: (category: string, value: string) => boolean\n    canEdit: () => boolean\n    getStatusDisplay: () => string\n    getMetadata: <T = unknown>(key: string) => T | undefined\n    setMetadata: (key: string, value: unknown) => void\n    getAgeInDays: () => number\n    isRecentlyUpdated: (withinDays?: number) => boolean\n    serialize: () => Record<string, unknown>\n  }\n}\n\n/**\n * Hook to fetch a single brandkit by ID with enhanced utilities and computed properties.\n *\n * @param brandkitId - The ID of the brandkit to fetch. If empty, no fetch will occur.\n * @param options - Configuration options for the API request\n * @param options.organizationId - Required organization ID for the request\n * @param options.includeDeleted - Whether to include deleted brandkits in the response\n * @returns Object containing the brandkit data, loading state, error state, computed properties, and utility functions\n *\n * @example\n * // Basic usage\n * const { brandkit, isLoading, error } = useBrandkitById('brandkit-123', {\n *   organizationId: 'org-456'\n * });\n *\n * // Enhanced usage with computed properties\n * const {\n *   brandkit,\n *   displayName,\n *   isDraft,\n *   hasLogo,\n *   utils,\n *   isLoading\n * } = useBrandkitById('brandkit-123', { organizationId: 'org-456' });\n *\n * // Using utility functions\n * const canEdit = utils.canEdit();\n * const industryTags = utils.getTagsByCategory('industry');\n * const customData = utils.getMetadata<string>('customField');\n * utils.setMetadata('lastViewed', new Date().toISOString());\n *\n * // Using computed properties\n * if (isDraft) {\n *   console.log(`${displayName} is a draft brandkit`);\n * }\n *\n * if (hasLogo) {\n *   console.log(`${displayName} has a logo`);\n * }\n */\nexport function useBrandkitById(\n  brandkitId: string = \"\",\n  options?: Omit<UseBrandkitByIdOptions, \"brandkitId\">\n): UseBrandkitsByIdProps {\n  const [brandkit, setBrandkit] = useState<Brandkit | null>(null)\n  const [isLoading, setIsLoading] = useState(true)\n  const [error, setError] = useState<Error | null>(null)\n\n  // Add local metadata state for mutations\n  const [localMetadata, setLocalMetadata] = useState<Record<string, unknown>>(\n    {}\n  )\n\n  const fetchBrandkit = useCallback(async () => {\n    if (!brandkitId) {\n      setBrandkit(null)\n      setIsLoading(false)\n      return\n    }\n\n    try {\n      setIsLoading(true)\n      setError(null)\n\n      const response =\n        await brands.getBrandKitApiBrandsV1OrganizationsOrganizationIdBrandkitsBrandkitIdGet(\n          {\n            path: {\n              organizationId: options?.organizationId || \"\",\n              brandkitId: brandkitId,\n            },\n            query: {\n              includeDeleted: options?.includeDeleted,\n            },\n          }\n        )\n\n      setBrandkit(\n        response.data\n          ? brandkitFromApiResponse(response.data as GetBrandKitModelResponse)\n          : null\n      )\n    } catch (err) {\n      console.error(\"Brandkit fetch error:\", err)\n\n      // Handle ky HTTPError specifically\n      if (err instanceof HTTPError) {\n        setError(\n          new Error(\n            `API Error: ${err.response.status} - ${err.response.statusText}`\n          )\n        )\n      } else {\n        setError(\n          err instanceof Error ? err : new Error(\"Failed to fetch brandkit\")\n        )\n      }\n      setBrandkit(null)\n    } finally {\n      setIsLoading(false)\n    }\n  }, [brandkitId, options?.organizationId, options?.includeDeleted])\n\n  useEffect(() => {\n    fetchBrandkit()\n  }, [brandkitId, options?.organizationId, options?.includeDeleted])\n\n  // Computed properties using useMemo for performance\n  const displayName = useMemo(\n    () => (brandkit ? getBrandkitDisplayName(brandkit) : null),\n    [brandkit]\n  )\n\n  const hasLogo = useMemo(\n    () => (brandkit ? hasBrandkitLogo(brandkit) : false),\n    [brandkit]\n  )\n\n  const isDraft = useMemo(\n    () => (brandkit ? isDraftBrandkit(brandkit) : false),\n    [brandkit]\n  )\n\n  const isPublished = useMemo(\n    () => (brandkit ? isPublishedBrandkit(brandkit) : false),\n    [brandkit]\n  )\n\n  const isDeleted = useMemo(\n    () => (brandkit ? isDeletedBrandkit(brandkit) : false),\n    [brandkit]\n  )\n\n  const isLocked = useMemo(\n    () => (brandkit ? isLockedBrandkit(brandkit) : false),\n    [brandkit]\n  )\n\n  const tagCategories = useMemo(\n    () =>\n      brandkit ? [...new Set(brandkit.tags.map((tag) => tag.category))] : [],\n    [brandkit]\n  )\n\n  const referenceCount = useMemo(\n    () => (brandkit ? brandkit.references.length : 0),\n    [brandkit]\n  )\n\n  // Utility functions bound to current brandkit\n  const utils = useMemo(\n    () => ({\n      /**\n       * Get all tag values for a specific category\n       */\n      getTagsByCategory: (category: string): readonly string[] =>\n        brandkit ? getBrandkitTagsByCategory(brandkit, category) : [],\n\n      /**\n       * Check if brandkit has a specific tag category/value combination\n       */\n      hasTag: (category: string, value: string): boolean =>\n        brandkit\n          ? getBrandkitTagsByCategory(brandkit, category).includes(value)\n          : false,\n\n      /**\n       * Check if brandkit can be edited (not locked and not deleted)\n       */\n      canEdit: (): boolean =>\n        brandkit\n          ? !isLockedBrandkit(brandkit) && !isDeletedBrandkit(brandkit)\n          : false,\n\n      /**\n       * Get user-friendly status display text\n       */\n      getStatusDisplay: (): string => {\n        if (!brandkit) return \"Not loaded\"\n        return (\n          brandkit.status.charAt(0).toUpperCase() + brandkit.status.slice(1)\n        )\n      },\n\n      /**\n       * Get metadata value with type safety\n       */\n      getMetadata: <T = unknown>(key: string): T | undefined => {\n        if (!brandkit) return undefined\n        const effectiveMetadata = { ...brandkit.metadata, ...localMetadata }\n        return effectiveMetadata[key] as T\n      },\n\n      /**\n       * Set local metadata (doesn't affect original brandkit)\n       */\n      setMetadata: (key: string, value: unknown): void => {\n        setLocalMetadata((prev) => ({ ...prev, [key]: value }))\n      },\n\n      /**\n       * Calculate age of brandkit in days\n       */\n      getAgeInDays: (): number => {\n        if (!brandkit) return 0\n        const now = new Date()\n        const created = brandkit.createdOn\n        return Math.floor(\n          (now.getTime() - created.getTime()) / (1000 * 60 * 60 * 24)\n        )\n      },\n\n      /**\n       * Check if brandkit was recently updated\n       */\n      isRecentlyUpdated: (withinDays: number = 7): boolean => {\n        if (!brandkit) return false\n        const now = new Date()\n        const updated = brandkit.updatedOn\n        const daysDiff = Math.floor(\n          (now.getTime() - updated.getTime()) / (1000 * 60 * 60 * 24)\n        )\n        return daysDiff <= withinDays\n      },\n\n      /**\n       * Serialize brandkit to plain object\n       */\n      serialize: (): Record<string, unknown> =>\n        brandkit ? brandkitToPlainObject(brandkit) : {},\n    }),\n    [brandkit, localMetadata]\n  )\n\n  return {\n    // Existing return values\n    isLoading,\n    brandkit,\n    error,\n    refetch: fetchBrandkit,\n\n    // New computed properties\n    displayName,\n    hasLogo,\n    isDraft,\n    isPublished,\n    isDeleted,\n    isLocked,\n    tagCategories,\n    referenceCount,\n\n    // New utilities\n    utils,\n  }\n}\n\n// Re-export domain utilities for convenience\nexport {\n  isDraftBrandkit,\n  isPublishedBrandkit,\n  isDeletedBrandkit,\n  isLockedBrandkit,\n  getBrandkitDisplayName,\n  hasBrandkitLogo,\n  getBrandkitTagsByCategory,\n  brandkitToPlainObject,\n  createBrandkit,\n  type BrandkitStatus,\n} from \"@sitecore/stream-ui-core\"\n",
      "type": "registry:component",
      "target": "components/stream-components/hooks/use-brandkit-by-id.ts"
    },
    {
      "path": "registry/new-york/stream/hooks/use-brandkits.ts",
      "content": "import { useCallback, useEffect, useMemo, useState } from \"react\"\nimport {\n  brandkitListFromApiResponse,\n  brands,\n  getBrandkitDisplayName,\n  getBrandkitTagsByCategory,\n  hasBrandkitLogo,\n  // HTTP error types\n  HTTPError,\n  isDeletedBrandkit,\n  // Domain model utilities\n  isDraftBrandkit,\n  isPublishedBrandkit,\n  type Brandkit,\n  // Domain types\n  type BrandkitStatus,\n  // HeyAPI generated types\n  type ListBrandKitsApiBrandsV1OrganizationsOrganizationIdBrandkitsGetData,\n  type ListBrandKitsModelResponse,\n} from \"@sitecore/stream-ui-core\"\n\n// Hook options type - using HeyAPI generated types\nexport type UseBrandkitsOptions =\n  ListBrandKitsApiBrandsV1OrganizationsOrganizationIdBrandkitsGetData[\"path\"] &\n    (ListBrandKitsApiBrandsV1OrganizationsOrganizationIdBrandkitsGetData[\"query\"] extends undefined\n      ? object\n      : ListBrandKitsApiBrandsV1OrganizationsOrganizationIdBrandkitsGetData[\"query\"])\n\nexport interface UseBrandkitsReturn {\n  // Existing properties (unchanged)\n  isLoading: boolean\n  brandkits: Brandkit[]\n  error: Error | null\n  refetch: () => Promise<void>\n\n  // New computed data\n  draftBrandkits: Brandkit[]\n  publishedBrandkits: Brandkit[]\n  totalCount: number\n\n  // New utilities\n  utils: {\n    findByName: (name: string) => Brandkit | undefined\n    filterByStatus: (status: BrandkitStatus) => Brandkit[]\n    filterByTag: (category: string, value: string) => Brandkit[]\n    getDisplayNames: () => string[]\n    summary: () => {\n      total: number\n      drafts: number\n      published: number\n      deleted: number\n      withLogos: number\n    }\n  }\n}\n\n/**\n * Hook to fetch brandkits from the API with enhanced utilities and computed properties.\n *\n * @param options - Configuration options for the API request\n * @param options.organizationId - Required organization ID for the request\n * @param options.pageSize - Number of brandkits to fetch per page (default: 50)\n * @param options.pageNumber - Page number to fetch (default: 1)\n * @param options.search - Search term to filter brandkits\n * @param options.status - Filter by brandkit status\n * @param options.includeDeleted - Whether to include deleted brandkits\n * @param options.parentId - Filter by parent brandkit ID\n * @param options.referenceType - Filter by reference type\n * @param options.referenceId - Filter by reference ID\n * @returns Object containing the brandkits data, loading state, error state, computed properties, and utility functions\n *\n * @example\n * // Basic usage\n * const { brandkits, isLoading, error } = useBrandkits({\n *   organizationId: 'org-123',\n *   pageSize: 10,\n *   pageNumber: 1,\n * });\n *\n * // Enhanced usage with computed properties\n * const {\n *   brandkits,\n *   draftBrandkits,\n *   publishedBrandkits,\n *   totalCount,\n *   utils,\n *   isLoading\n * } = useBrandkits({\n *   organizationId: 'org-123',\n *   pageSize: 20\n * });\n *\n * // Using utility functions\n * const brandkitByName = utils.findByName('My Brandkit');\n * const draftBrandkits = utils.filterByStatus('draft');\n * const industryBrandkits = utils.filterByTag('industry', 'technology');\n * const displayNames = utils.getDisplayNames();\n * const summary = utils.summary();\n *\n * // Using computed properties\n * console.log(`Total brandkits: ${totalCount}`);\n * console.log(`Draft brandkits: ${draftBrandkits.length}`);\n * console.log(`Published brandkits: ${publishedBrandkits.length}`);\n */\nexport function useBrandkits(\n  options?: UseBrandkitsOptions\n): UseBrandkitsReturn {\n  const [brandkits, setBrandkits] = useState<Brandkit[]>([])\n  const [isLoading, setIsLoading] = useState(true)\n  const [error, setError] = useState<Error | null>(null)\n\n  const fetchBrandkits = useCallback(async () => {\n    if (!options?.organizationId) {\n      console.error(\n        \"useBrandkits: organizationId is required but was not provided\"\n      )\n      setIsLoading(false)\n      setBrandkits([])\n      setError(null)\n      return\n    }\n\n    try {\n      setIsLoading(true)\n      setError(null)\n\n      const response =\n        await brands.listBrandKitsApiBrandsV1OrganizationsOrganizationIdBrandkitsGet(\n          {\n            path: { organizationId: options?.organizationId || \"\" },\n            query: {\n              pageSize: options?.pageSize || 50,\n              pageNumber: options?.pageNumber || 1,\n              search: options?.search,\n              status: options?.status,\n              includeDeleted: options?.includeDeleted,\n              parentId: options?.parentId,\n              referenceType: options?.referenceType,\n              referenceId: options?.referenceId,\n            },\n          }\n        )\n\n      const fetchedBrandkits = response.data\n        ? brandkitListFromApiResponse(\n            response.data as ListBrandKitsModelResponse\n          )\n        : []\n\n      setBrandkits(fetchedBrandkits)\n    } catch (err) {\n      console.error(\"Brandkits fetch error:\", err)\n\n      // Handle ky HTTPError specifically\n      if (err instanceof HTTPError) {\n        setError(\n          new Error(\n            `API Error: ${err.response.status} - ${err.response.statusText}`\n          )\n        )\n      } else {\n        setError(\n          err instanceof Error ? err : new Error(\"Failed to fetch brandkits\")\n        )\n      }\n      setBrandkits([])\n    } finally {\n      setIsLoading(false)\n    }\n  }, [\n    options?.organizationId,\n    options?.pageSize,\n    options?.search,\n    options?.status,\n    options?.includeDeleted,\n  ])\n\n  useEffect(() => {\n    if (options?.organizationId) {\n      fetchBrandkits()\n    } else {\n      console.error(\n        \"useBrandkits: organizationId is required but was not provided\"\n      )\n\n      setIsLoading(false)\n      setBrandkits([])\n      setError(null)\n    }\n  }, [\n    options?.organizationId,\n    options?.pageSize,\n    options?.pageNumber,\n    options?.search,\n    options?.status,\n    options?.includeDeleted,\n    options?.parentId,\n    options?.referenceType,\n    options?.referenceId,\n  ])\n\n  // Computed values with useMemo for performance\n  const draftBrandkits = useMemo(\n    () => brandkits.filter(isDraftBrandkit),\n    [brandkits]\n  )\n\n  const publishedBrandkits = useMemo(\n    () => brandkits.filter(isPublishedBrandkit),\n    [brandkits]\n  )\n\n  // Context-aware utilities object\n  const utils = useMemo(\n    () => ({\n      /**\n       * Find a brandkit by name (case-insensitive search)\n       * @param name - The name to search for\n       * @returns The matching brandkit or undefined\n       */\n      findByName: (name: string): Brandkit | undefined => {\n        const searchName = name.toLowerCase()\n        return brandkits.find((brandkit) =>\n          getBrandkitDisplayName(brandkit).toLowerCase().includes(searchName)\n        )\n      },\n\n      /**\n       * Filter brandkits by status\n       * @param status - The status to filter by\n       * @returns Array of brandkits with the specified status\n       */\n      filterByStatus: (status: BrandkitStatus): Brandkit[] => {\n        return brandkits.filter((brandkit) => brandkit.status === status)\n      },\n\n      /**\n       * Filter brandkits by tag category and value\n       * @param category - The tag category to filter by\n       * @param value - The tag value to filter by\n       * @returns Array of brandkits that have the specified tag\n       */\n      filterByTag: (category: string, value: string): Brandkit[] => {\n        return brandkits.filter((brandkit) => {\n          const brandkitTags = getBrandkitTagsByCategory(brandkit, category)\n          return brandkitTags.includes(value)\n        })\n      },\n\n      /**\n       * Get display names for all brandkits\n       * @returns Array of display names\n       */\n      getDisplayNames: (): string[] => {\n        return brandkits.map(getBrandkitDisplayName)\n      },\n\n      /**\n       * Get summary statistics for the brandkits collection\n       * @returns Object with counts for different brandkit states\n       */\n      summary: () => {\n        const total = brandkits.length\n        const drafts = brandkits.filter(isDraftBrandkit).length\n        const published = brandkits.filter(isPublishedBrandkit).length\n        const deleted = brandkits.filter(isDeletedBrandkit).length\n        const withLogos = brandkits.filter(hasBrandkitLogo).length\n\n        return {\n          total,\n          drafts,\n          published,\n          deleted,\n          withLogos,\n        }\n      },\n    }),\n    [brandkits]\n  )\n\n  return {\n    // Existing return values (unchanged)\n    isLoading,\n    brandkits,\n    error,\n    refetch: fetchBrandkits,\n\n    // New computed values\n    draftBrandkits,\n    publishedBrandkits,\n    totalCount: brandkits.length,\n\n    // New utilities\n    utils,\n  }\n}\n\n// Re-export domain utilities for better developer experience\nexport {\n  isDraftBrandkit,\n  isPublishedBrandkit,\n  isDeletedBrandkit,\n  isLockedBrandkit,\n  getBrandkitDisplayName,\n  hasBrandkitLogo,\n  getBrandkitTagsByCategory,\n  createBrandkit,\n  type BrandkitStatus,\n  type Tag,\n  type BrandkitReference,\n} from \"@sitecore/stream-ui-core\"\n",
      "type": "registry:component",
      "target": "components/stream-components/hooks/use-brandkits.ts"
    },
    {
      "path": "registry/new-york/stream/hooks/use-chat.ts",
      "content": "import { useState } from \"react\"\n\nexport function useChat() {\n  const [chatId, setChatId] = useState<string>(\"\")\n  const [isNewChat, setNewChat] = useState<boolean>(false)\n\n  function newChat(cb?: () => void) {\n    setNewChat(true)\n    setChatId(\"\")\n\n    queueMicrotask(function () {\n      setNewChat(false)\n      cb?.()\n    })\n  }\n\n  return { chatId, setChatId, isNewChat, newChat }\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/hooks/use-chat.ts"
    },
    {
      "path": "registry/new-york/stream/hooks/use-contenthub-brandkits.ts",
      "content": "import { useCallback, useEffect, useMemo, useState } from \"react\"\nimport {\n  brandkitFromApiResponse,\n  contenthubBrandsBrandKit,\n  getBrandkitDisplayName,\n  HTTPError,\n  // Domain utilities\n  isDraftBrandkit,\n  isPublishedBrandkit,\n  normalizeContentHubBrandkitFromHeyApi,\n  type Brandkit,\n  // Types\n  type BrandkitStatus,\n} from \"@sitecore/stream-ui-core\"\n\n// Hook options - ContentHub specific parameters\nexport interface UseContentHubBrandkitsOptions {\n  brandId: number // Required ContentHub brand ID\n  search?: string // Search term (client-side filtering)\n}\n\n// Same return interface as default useBrandkits for consistency\nexport interface UseContentHubBrandkitsReturn {\n  // Core data\n  isLoading: boolean\n  brandkits: Brandkit[]\n  error: Error | null\n  refetch: () => Promise<void>\n\n  // Computed data (same as default hook)\n  draftBrandkits: Brandkit[]\n  publishedBrandkits: Brandkit[]\n  totalCount: number\n\n  // Pagination metadata\n  pagination: {\n    page: number\n    limit: number\n    total: number\n    hasNext: boolean\n    hasPrev: boolean\n    totalPages: number\n  }\n\n  // Same utilities as default hook\n  utils: {\n    findByName: (name: string) => Brandkit | undefined\n    filterByStatus: (status: BrandkitStatus) => Brandkit[]\n    getDisplayNames: () => string[]\n    summary: () => {\n      total: number\n      drafts: number\n      published: number\n      deleted: number\n      withLogos: number\n    }\n  }\n}\n\n/**\n * Hook to fetch brandkits from ContentHub API for a specific brand.\n *\n * Returns the same interface as useBrandkits() for consistent developer experience.\n *\n * @param options - ContentHub-specific options\n * @param options.brandId - Required ContentHub brand ID (number)\n * @param options.search - Optional search term (client-side filtering)\n *\n * @example\n * ```typescript\n * // Basic usage\n * const { brandkits, isLoading, error } = useContentHubBrandkits({\n *   brandId: 123\n * });\n *\n * // With pagination and search\n * const {\n *   brandkits,\n *   utils,\n *   draftBrandkits\n * } = useContentHubBrandkits({\n *   brandId: 123,\n *   search: 'nike'\n * });\n *\n * // Same utilities as default hook\n * const brandkitByName = utils.findByName('Nike Air');\n * const summary = utils.summary();\n * ```\n */\nexport function useContentHubBrandkits(\n  options: UseContentHubBrandkitsOptions\n): UseContentHubBrandkitsReturn {\n  const [isLoading, setIsLoading] = useState(true)\n  const [error, setError] = useState<Error | null>(null)\n  const [allBrandkits, setAllBrandkits] = useState<Brandkit[]>([])\n\n  const fetchBrandkits = useCallback(async () => {\n    try {\n      setIsLoading(true)\n      setError(null)\n\n      // Call ContentHub API - no pagination parameters (not supported)\n      const response =\n        await contenthubBrandsBrandKit.getApiV1BrandsByBrandIdBrandkits({\n          path: {\n            brandId: options.brandId,\n          },\n        })\n\n      // Transform ContentHub response to domain model\n      const data = response.data as any\n      if (data && Array.isArray(data)) {\n        // ContentHub -> Standard -> Domain transformation\n        const normalizedItems = data\n          .map(normalizeContentHubBrandkitFromHeyApi) // ContentHub -> Standard format\n          .map(brandkitFromApiResponse) // Standard -> Domain model\n\n        setAllBrandkits(normalizedItems)\n      } else {\n        setAllBrandkits([])\n      }\n    } catch (err) {\n      console.error(\"ContentHub brandkits fetch error:\", err)\n\n      if (err instanceof HTTPError) {\n        setError(\n          new Error(\n            `API Error: ${err.response.status} - ${err.response.statusText}`\n          )\n        )\n      } else {\n        setError(\n          err instanceof Error ? err : new Error(\"Failed to fetch brandkits\")\n        )\n      }\n      setAllBrandkits([])\n    } finally {\n      setIsLoading(false)\n    }\n  }, [options.brandId])\n\n  useEffect(() => {\n    fetchBrandkits()\n  }, [fetchBrandkits])\n\n  // Client-side filtering only\n  const brandkits = useMemo(() => {\n    if (!options.search) {\n      return allBrandkits\n    }\n\n    const searchTerm = options.search.toLowerCase()\n    return allBrandkits.filter(\n      (brandkit) =>\n        getBrandkitDisplayName(brandkit).toLowerCase().includes(searchTerm) ||\n        brandkit.description.toLowerCase().includes(searchTerm)\n    )\n  }, [allBrandkits, options.search])\n\n  // Simple pagination metadata (no actual pagination)\n  const pagination = useMemo(\n    () => ({\n      page: 1,\n      limit: brandkits.length,\n      total: brandkits.length,\n      hasNext: false,\n      hasPrev: false,\n      totalPages: 1,\n    }),\n    [brandkits.length]\n  )\n\n  // Computed values (same as default hook)\n  const draftBrandkits = useMemo(\n    () => brandkits.filter(isDraftBrandkit),\n    [brandkits]\n  )\n\n  const publishedBrandkits = useMemo(\n    () => brandkits.filter(isPublishedBrandkit),\n    [brandkits]\n  )\n\n  // Same utilities as default hook for consistent developer experience\n  const utils = useMemo(\n    () => ({\n      findByName: (name: string): Brandkit | undefined => {\n        const searchName = name.toLowerCase()\n        return brandkits.find((brandkit) =>\n          getBrandkitDisplayName(brandkit).toLowerCase().includes(searchName)\n        )\n      },\n\n      filterByStatus: (status: BrandkitStatus): Brandkit[] => {\n        return brandkits.filter((brandkit) => brandkit.status === status)\n      },\n\n      getDisplayNames: (): string[] => {\n        return brandkits.map(getBrandkitDisplayName)\n      },\n\n      summary: () => {\n        const total = brandkits.length\n        const drafts = draftBrandkits.length\n        const published = publishedBrandkits.length\n        const deleted = brandkits.filter((b) => b.deletedAt !== null).length\n        const withLogos = brandkits.filter((b) => b.logo !== \"\").length\n\n        return { total, drafts, published, deleted, withLogos }\n      },\n    }),\n    [brandkits, draftBrandkits, publishedBrandkits]\n  )\n\n  return {\n    // Core data\n    isLoading,\n    brandkits,\n    error,\n    refetch: fetchBrandkits,\n\n    // Computed data\n    draftBrandkits,\n    publishedBrandkits,\n    totalCount: brandkits.length,\n\n    // Pagination\n    pagination,\n\n    // Utilities (identical to default hook)\n    utils,\n  }\n}\n\n// Re-export domain utilities for convenience\nexport {\n  isDraftBrandkit,\n  isPublishedBrandkit,\n  getBrandkitDisplayName,\n  type BrandkitStatus,\n} from \"@sitecore/stream-ui-core\"\n",
      "type": "registry:component",
      "target": "components/stream-components/hooks/use-contenthub-brandkits.ts"
    },
    {
      "path": "registry/new-york/stream/hooks/use-get-chat-messages.ts",
      "content": "import { useCallback } from \"react\"\nimport {\n  chat,\n  type ListUserChatMessagesModelResponseV2,\n} from \"@sitecore/stream-ui-core\"\n\n/**\n * Custom hook to fetch chat messages for a specific chat.\n *\n * @param {string} orgId - The organization ID.\n * @param {string} userId - The user ID.\n * @return {(chatId: string) => Promise<ListUserChatMessagesModelResponseV2[]>} - A function that accepts a chat ID and returns a promise resolving to an array of chat messages.\n */\nexport function useGetChatMessages(\n  orgId: string,\n  userId: string\n): (chatId: string) => Promise<ListUserChatMessagesModelResponseV2[]> {\n  return useCallback(\n    async (chatId: string): Promise<ListUserChatMessagesModelResponseV2[]> => {\n      const { data } =\n        await chat.listUserChatMessagesV2ApiChatsV2OrganizationsOrganizationIdUsersUserIdChatsChatIdMessagesGet(\n          {\n            path: {\n              organizationId: orgId,\n              userId,\n              chatId,\n            },\n          }\n        )\n\n      return data ?? []\n    },\n    [orgId, userId]\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/hooks/use-get-chat-messages.ts"
    },
    {
      "path": "registry/new-york/stream/hooks/use-get-chats.ts",
      "content": "import { useCallback } from \"react\"\nimport {\n  chat,\n  type ListUserChatsModelResponseV2,\n} from \"@sitecore/stream-ui-core\"\n\n/**\n * Hook to retrieve the list of user chats for a specific organization and user.\n *\n * @param {string} orgId - The unique identifier of the organization.\n * @param {string} userId - The unique identifier of the user whose chats are to be fetched.\n * @return {function(): Promise<ListUserChatsModelResponseV2[]>} A function that, when invoked, returns a promise resolving to an array of chat data associated with the user.\n */\nexport function useGetChats(\n  orgId: string,\n  userId: string\n): () => Promise<ListUserChatsModelResponseV2[]> {\n  return useCallback(async (): Promise<ListUserChatsModelResponseV2[]> => {\n    const { data } =\n      await chat.listUserChatsV2ApiChatsV2OrganizationsOrganizationIdUsersUserIdChatsGet(\n        {\n          path: {\n            organizationId: orgId,\n            userId,\n          },\n        }\n      )\n\n    return data ?? []\n  }, [orgId, userId])\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/hooks/use-get-chats.ts"
    },
    {
      "path": "registry/new-york/stream/lib/utils.ts",
      "content": "import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/lib/utils.ts"
    },
    {
      "path": "registry/new-york/stream/ui/stream-icon.tsx",
      "content": "import React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nexport interface StreamIconProps\n  extends React.SVGAttributes<SVGSVGElement>,\n    VariantProps<typeof iconVariants> {\n  path: string\n  aiGradient?:\n    | \"50\"\n    | \"100\"\n    | \"200\"\n    | \"300\"\n    | \"400\"\n    | \"500\"\n    | \"600\"\n    | \"700\"\n    | \"800\"\n    | \"900\"\n}\n\nconst iconVariants = cva(\"inline-block align-middle flex-shrink-0 leading-4\", {\n  variants: {\n    size: {\n      default: \"stream-w-icon stream-h-icon\",\n      \"3xs\": \"stream-w-icon-3xs stream-h-icon-3xs\",\n      \"2xs\": \"stream-w-icon-2xs stream-h-icon-2xs\",\n      xs: \"stream-w-icon-xs stream-h-icon-xs\",\n      sm: \"stream-w-icon-sm stream-h-icon-sm\",\n      md: \"stream-w-icon-md stream-h-icon-md\",\n      lg: \"stream-w-icon-lg stream-h-icon-lg\",\n      xl: \"stream-w-icon-xl stream-h-icon-xl\",\n      \"2xl\": \"stream-w-icon-2xl stream-h-icon-2xl\",\n      \"3xl\": \"stream-w-icon-3xl stream-h-icon-3xl\",\n      \"4xl\": \"stream-w-icon-4xl stream-h-icon-4xl\",\n      \"5xl\": \"stream-w-icon-5xl stream-h-icon-5xl\",\n      \"6xl\": \"stream-w-icon-6xl stream-h-icon-6xl\",\n      \"7xl\": \"stream-w-icon-7xl stream-h-icon-7xl\",\n      \"8xl\": \"stream-w-icon-8xl stream-h-icon-7xl\",\n    },\n  },\n  defaultVariants: {\n    size: \"default\",\n  },\n})\n\nexport function StreamIcon({\n  path,\n  size,\n  className,\n  aiGradient,\n  ...rest\n}: StreamIconProps) {\n  return (\n    <svg\n      fill=\"currentColor\"\n      viewBox=\"0 0 24 24\"\n      {...rest}\n      className={iconVariants({ size, className })}\n    >\n      {aiGradient && (\n        <defs>\n          <linearGradient id=\"ai-gradient\" y1=\"100%\" y2=\"0\">\n            <stop stopColor={`var(--purple-${aiGradient})`} offset=\"0%\" />\n            <stop stopColor={`var(--red-${aiGradient})`} offset=\"100%\" />\n          </linearGradient>\n        </defs>\n      )}\n      <path fill={aiGradient ? \"url(#ai-gradient)\" : \"currentColor\"} d={path} />\n    </svg>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/ui/stream-icon.tsx"
    },
    {
      "path": "registry/new-york/stream/ui/stream-spinner.tsx",
      "content": "import React from \"react\"\n\nimport { cn } from \"../lib/utils\"\n\ninterface StreamSpinnerProps extends React.HTMLAttributes<HTMLDivElement> {\n  size?: \"xs\" | \"sm\" | \"md\" | \"lg\" | \"xl\"\n  message?: string\n  withOverlay?: boolean\n  fullscreen?: boolean\n}\n\nconst sizeClasses = {\n  xs: \"w-3 h-3\",\n  sm: \"w-4 h-4\",\n  md: \"w-6 h-6\",\n  lg: \"w-8 h-8\",\n  xl: \"w-12 h-12\",\n}\n\nfunction StreamSpinner({\n  size = \"md\",\n  className,\n  message,\n  withOverlay = false,\n  fullscreen = false,\n  ...props\n}: StreamSpinnerProps) {\n  const spinnerClasses = cn(\n    \"inline-block rounded-full animate-spin border-4\",\n    \"border-t-purple-600 border-r-purple-600 border-b-gray-200 border-l-gray-200\",\n    sizeClasses[size],\n    className\n  )\n\n  const SpinnerElement = (\n    <div className=\"text-center\">\n      <div className={spinnerClasses} data-testid=\"stream-spinner\" {...props} />\n      {message && <p className=\"mt-6 text-sm text-gray-600\">{message}</p>}\n    </div>\n  )\n\n  if (fullscreen) {\n    return (\n      <div className=\"fixed inset-0 z-50 flex items-center justify-center bg-white/90\">\n        {SpinnerElement}\n      </div>\n    )\n  }\n\n  if (withOverlay) {\n    return (\n      <div className=\"flex h-full w-full items-center justify-center bg-white/90\">\n        {SpinnerElement}\n      </div>\n    )\n  }\n\n  return SpinnerElement\n}\n\nexport { StreamSpinner, type StreamSpinnerProps }\n",
      "type": "registry:component",
      "target": "components/stream-components/ui/stream-spinner.tsx"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/utils/index.ts",
      "content": "import { type ToolInvocationUIPart } from \"@ai-sdk/ui-utils\"\nimport { remarkDocx } from \"@m2d/remark-docx\"\nimport {\n  abTestingClient,\n  brainstormingClient,\n  brandsClient,\n  briefClient,\n  chatClient,\n  createStreamFetch,\n  documentsClient,\n  type ContentModelRead,\n  type ListUserChatMessagesModelResponseV2,\n} from \"@sitecore/stream-ui-core\"\nimport { merge, omit, uniqueId } from \"lodash\"\nimport rehypeParse from \"rehype-parse\"\nimport rehypeRemark from \"rehype-remark\"\nimport { remark } from \"remark\"\nimport remarkHtml from \"remark-html\"\nimport remarkStringify from \"remark-stringify\"\nimport { toast } from \"sonner\"\nimport strip from \"strip-markdown\"\n\nimport {\n  type ExtractSourceRecordProps,\n  type ExtractSourcesProps,\n} from \"../types\"\nimport type { Source } from \"../types\"\nimport { type SearchContentProps, type WorkflowItem } from \"../Workflow\"\n\n/**\n * A list of tools that are allowed to be utilized within the application or system.\n * Each tool in the list represents a specific functionality or feature that is\n * permissible for use. This constant serves as a reference to define the scope of\n * operations that the system can perform.\n *\n * Tools included in this array:\n * - 'knowledge_search': Enables searching within a knowledge base or related resources.\n * - 'web_search': Facilitates searching for information on the web.\n * - 'brand_knowledge': Accesses information related to specific brands.\n * - 'answer': Provides direct answers to queries.\n * - 'followup_questions': Allows for asking follow-up questions related to a query or context.\n * - 'brief': Generates summaries or brief overviews of information.\n * - 'brainstorming': Assists in generating ideas or exploring creative solutions.\n *\n * The variable is intended to be used as a control mechanism to identify functional capabilities\n * that are authorized for operations.\n */\nconst ALLOWED_TOOLS = [\n  \"knowledge_search\",\n  \"web_search\",\n  \"brand_knowledge\",\n  \"answer\",\n  \"followup_questions\",\n  \"brief\",\n  \"brainstorming\",\n]\n\n/**\n * An object that maps keys to their corresponding titles representing various tool source categories.\n *\n * The object contains the following key-value pairs:\n * - `knowledge_search`: Represents the title for knowledge source tools.\n * - `web_search`: Represents the title for web-based source tools.\n * - `brand_knowledge`: Represents the title for sources from the Brand Kit section.\n *\n * This configuration is intended to provide descriptive titles for displaying or referencing\n * specific tool categories across an application.\n */\nexport const TOOLS_SOURCES_TITLES = {\n  knowledge_search: \"Knowledge sources\",\n  web_search: \"Web sources\",\n  brand_knowledge: \"Brand Kit section sources\",\n}\n\n/**\n * A regular expression pattern used to match and remove specific characters from text.\n *\n * This regex matches the following characters:\n * - Newline characters (`\\n`)\n * - Carriage return characters (`\\r`)\n * - Whitespace characters (such as spaces and tabs, represented by `\\s`)\n * - Backslashes (`\\`)\n *\n * The global flag (`g`) ensures that all occurrences of the matched characters\n * in the target string are identified and replaced or removed.\n *\n * Use this regular expression to sanitize or normalize text by stripping\n * out unwanted characters as defined in the pattern.\n */\nexport const STRIP_TEXT_REGEX = /[\\n\\r\\s\\\\]/g\n\n/**\n * Configures and initializes multiple API clients for streaming messages\n * based on the given parameters.\n *\n * @param {string} token - The authentication token used to access the APIs.\n * @param {string} region - The region identifier to determine the API base URLs.\n * @param {'dev' | 'qa' | 'staging' | 'preprod' | 'prod'} env - The environment\n * key specifying which stage of the platform to connect to.\n * @return {{clientsLoaded: boolean}} - An object indicating whether the API\n * clients were successfully configured and loaded.\n */\nexport function useStreamMessagesClientsConfig(\n  token: string,\n  region: string,\n  env: \"dev\" | \"qa\" | \"staging\" | \"preprod\" | \"prod\"\n): {\n  clientsLoaded: boolean\n} {\n  if (!token || !region || !env) {\n    toast.error(\"Missing required parameters\")\n    return {\n      clientsLoaded: false,\n    }\n  }\n\n  const baseUrlEnv = {\n    dev: \"-dev.sitecore-staging.cloud\",\n    qa: \"-qa.sitecore-staging.cloud\",\n    staging: \"-staging.sitecore-staging.cloud\",\n    preprod: \"-preprod.sitecorecloud.io\",\n    prod: \"sitecorecloud.io\",\n  }\n\n  try {\n    brandsClient.setConfig({\n      baseUrl: `https://ai-brands-api-${region}${baseUrlEnv[env]}`,\n      fetch: createStreamFetch({\n        tokenProvider: async () => token,\n        refreshTokenProvider: async () => token,\n      }),\n    })\n\n    chatClient.setConfig({\n      baseUrl: `https://ai-chat-api-${region}${baseUrlEnv[env]}`,\n      fetch: createStreamFetch({\n        tokenProvider: async () => token,\n        refreshTokenProvider: async () => token,\n      }),\n    })\n\n    documentsClient.setConfig({\n      baseUrl: `https://ai-documents-api-${region}${baseUrlEnv[env]}`,\n      fetch: createStreamFetch({\n        tokenProvider: async () => token,\n        refreshTokenProvider: async () => token,\n      }),\n    })\n\n    abTestingClient.setConfig({\n      baseUrl: `https://ai-ab-testing-api-${region}${baseUrlEnv[env]}`,\n      fetch: createStreamFetch({\n        tokenProvider: async () => token,\n        refreshTokenProvider: async () => token,\n      }),\n    })\n\n    briefClient.setConfig({\n      baseUrl: `https://ai-brief-api-${region}${baseUrlEnv[env]}`,\n      fetch: createStreamFetch({\n        tokenProvider: async () => token,\n        refreshTokenProvider: async () => token,\n      }),\n    })\n\n    brainstormingClient.setConfig({\n      baseUrl: `https://ai-brainstorming-api-${region}${baseUrlEnv[env]}`,\n      fetch: createStreamFetch({\n        tokenProvider: async () => token,\n        refreshTokenProvider: async () => token,\n      }),\n    })\n\n    return {\n      clientsLoaded: true,\n    }\n  } catch (error) {\n    toast.error(\"Error loading clients\")\n    return {\n      clientsLoaded: false,\n    }\n  }\n}\n\n/**\n * Converts a given Markdown string into plain text by stripping out all Markdown syntax.\n *\n * @param {string} markdownText - The string containing Markdown content to be converted.\n * @return {string} The plain text representation of the given Markdown content.\n */\nexport function markdownToPlainText(markdownText: string): string {\n  const file = remark().use(strip).processSync(markdownText)\n  return String(file)\n}\n\n/**\n * Converts a given Markdown string to its corresponding HTML representation.\n *\n * @param {string} markdownText - The input string written in Markdown syntax.\n * @return {string} - The converted string in HTML format.\n */\nexport function markdownToHtml(markdownText: string): string {\n  const file = remark().use(remarkHtml).processSync(markdownText)\n  return String(file)\n}\n\n/**\n * Converts a Markdown formatted string into a Microsoft Word document format (DOCX).\n * This function utilizes remark and remarkDocx libraries for the conversion process.\n *\n * @param {string} markdownText - The string containing Markdown content to be converted.\n * @return {VFile} Returns a VFile object containing the converted DOCX document data.\n */\nexport function markdownToDocx(markdownText: string) {\n  return remark().use(remarkDocx).processSync(markdownText)\n}\n\n/**\n * Converts the given markdown text into a DOCX file and triggers a download.\n *\n * @param {string} markdownText - The markdown content to be converted into a DOCX file.\n * @param {string} [fileName='document'] - The desired name for the downloaded DOCX file (excluding the file extension).\n * @return {void} This function does not return any value; it initiates a file download in the browser.\n */\nexport function saveToDocx(\n  markdownText: string,\n  fileName: string = \"document\"\n): void {\n  const { result } = markdownToDocx(markdownText) as unknown as {\n    result: Promise<Blob>\n  }\n\n  result.then((blob) => {\n    const url = URL.createObjectURL(blob)\n    const link = document.createElement(\"a\")\n    link.href = url\n    link.download = `${fileName}.docx`\n    link.click()\n    URL.revokeObjectURL(url)\n  })\n}\n\n/**\n * Converts a string of HTML content into Markdown format.\n *\n * @param {string} htmlText - The HTML string to be converted to Markdown.\n * @return {string} The converted Markdown string.\n */\nexport function htmlToMarkdown(htmlText: string): string {\n  const file = remark()\n    .use(rehypeParse, { emitParseErrors: true, duplicateAttribute: false })\n    .use(rehypeRemark)\n    .use(remarkStringify)\n    .processSync(htmlText)\n\n  return String(file)\n}\n\n/**\n * Replaces all occurrences of escaped newline characters (\\n) with actual newline characters in the provided string.\n *\n * @param {string} text - The input string where escaped newline characters will be replaced. Defaults to an empty string if no input is provided.\n * @return {string} The resulting string with escaped newline characters replaced by actual newline characters.\n */\nexport function replaceNewLines(text: string = \"\"): string {\n  return text.replace(/\\\\n/g, \"\\n\")\n}\n\n/**\n * Formats a given date input into a localized string in the format \"Month Day, Year\".\n *\n * @param {string | number | Date} input - The date input to be formatted. It can be a string, timestamp, or Date object.\n * @return {string} The formatted date string in the \"Month Day, Year\" format.\n */\nexport function formatDate(input: string | number | Date): string {\n  const date = new Date(input)\n  return date.toLocaleDateString(\"en-US\", {\n    month: \"long\",\n    day: \"numeric\",\n    year: \"numeric\",\n  })\n}\n\n/**\n * Copies the provided text to the system clipboard.\n *\n * @param {string} text - The text content to copy to the clipboard.\n * @return {void} This function does not return a value.\n * @throws Will throw an error if the window object is not defined.\n */\nexport function copyToClipboard(text: string): void {\n  if (typeof window === \"undefined\")\n    throw new Error(\"Could not copy to clipboard, window is not defined.\")\n\n  if (window.navigator.clipboard) {\n    window.navigator.clipboard\n      .writeText(text)\n      .then(() => {\n        toast.success(\"Text copied to clipboard successfully\")\n      })\n      .catch((err) => {\n        toast.error(\"Failed to copy text: \", err)\n      })\n  }\n}\n\n/**\n * Pauses execution for a specified duration.\n *\n * @param {number} ms - The duration to sleep in milliseconds.\n * @return {Promise<void>} A promise that resolves after the specified duration.\n */\nexport function sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms))\n}\n\n/**\n * Converts the first character of a given string to uppercase.\n *\n * @param {string} text - The input string. Defaults to an empty string if not provided.\n * @return {string} A new string with the first character converted to uppercase.\n */\nexport function firstCharToUpperCase(text: string = \"\"): string {\n  return `${text?.charAt(0).toUpperCase()}${text?.slice(1)}`\n}\n\n/**\n * Removes duplicate objects from an array based on a specified property.\n *\n * @param {T[]} obj - The array of objects to filter for duplicates.\n * @param {K} prop - The property used to determine uniqueness.\n * @return {T[]} An array with duplicates removed based on the specified property.\n */\nexport function removeDuplicatesFromArray<T, K extends keyof T>(\n  obj: T[],\n  prop: K\n): T[] {\n  return Object.values(\n    obj.reduce((acc, cur) => {\n      const key = String(cur[prop]) as string | number | symbol\n\n      return {\n        ...acc,\n        [key]: cur,\n      }\n    }, {})\n  )\n}\n\n/**\n * Combines multiple source objects into a single aggregated source object, filtering out entries without valid content.\n *\n * @param {...ExtractSourceRecordProps[]} sources - One or more source objects to be merged and processed.\n * @return {ExtractSourcesProps} The aggregated and filtered sources object as per the defined processing rules.\n */\nexport function createSources(\n  ...sources: ExtractSourceRecordProps[]\n): ExtractSourcesProps {\n  return Object.entries(\n    merge({}, ...sources) as ExtractSourceRecordProps\n  ).filter(([, sources]) => !!sources?.length)\n}\n\n/**\n * A variable representing the extraction of Brand Kit section sources\n * from a workflow. This provides a mapping for the source of records\n * related to Brand Kit sections.\n *\n * @constant\n * @type {ExtractSourceRecordProps}\n * @default {'Brand Kit section sources': []}\n */\nexport const extractBrandkitSourcesFromWorkflow: ExtractSourceRecordProps = {\n  \"Brand Kit section sources\": [],\n}\n\n/**\n * Extracts source records from the brainstorming tool invocation found in the given array of parts.\n *\n * @param {ToolInvocationUIPart[] | undefined} parts - An array of tool invocation UI parts. If undefined, an empty array is assumed.\n * @return {ExtractSourceRecordProps} An aggregated object containing source records mapped to their corresponding source titles based on predefined tool source titles.\n */\nexport function extractSourcesFromBrainstorming(\n  parts: ToolInvocationUIPart[] | undefined\n): ExtractSourceRecordProps {\n  const partBrainstorming =\n    parts?.filter(\n      (part: ToolInvocationUIPart) =>\n        part?.toolInvocation?.toolName === \"brainstorming\"\n    ) ?? []\n\n  const workflowSearchItems =\n    partBrainstorming?.[0]?.toolInvocation?.args?.result?.workflow.filter(\n      ({ name }: WorkflowItem) => name === \"search\"\n    ) ?? []\n\n  const workflowSearchContent = workflowSearchItems\n    .reduce(\n      (acc: SearchContentProps[], cur: WorkflowItem): SearchContentProps[] => {\n        return [...acc, ...(cur.content as SearchContentProps[])]\n      },\n      [] as SearchContentProps[]\n    )\n    .map(\n      (\n        item: Record<\n          keyof typeof TOOLS_SOURCES_TITLES | \"question\",\n          Source[] | string\n        >\n      ) => omit(item, [\"question\"])\n    )\n\n  return (\n    workflowSearchContent.reduce(\n      (\n        acc: ExtractSourceRecordProps,\n        cur: ExtractSourceRecordProps\n      ): ExtractSourceRecordProps => {\n        const source: ExtractSourceRecordProps = {\n          ...acc,\n        }\n\n        for (const key in cur) {\n          const sourceName =\n            TOOLS_SOURCES_TITLES[key as keyof typeof TOOLS_SOURCES_TITLES]\n\n          const value = !Array.isArray(cur[key]) ? [] : cur[key]\n\n          source[sourceName] = removeDuplicatesFromArray(\n            sourceName in source ? [...source[sourceName], ...value] : value,\n            \"url\"\n          )\n        }\n\n        return {\n          ...source,\n        }\n      },\n      {} as ExtractSourceRecordProps\n    ) ?? {}\n  )\n}\n\n/**\n * Extracts and organizes sources from the provided ToolInvocationUIPart array.\n *\n * @param {ToolInvocationUIPart[] | undefined} parts - An array of ToolInvocationUIPart objects or undefined.\n * Each object in the array may contain tool invocation data, including tool name and arguments.\n * The arguments may include data about sources with properties such as type and URL.\n *\n * @return {ExtractSourceRecordProps} An object where the keys represent source names derived from tool names,\n * and the values are arrays of sources associated with those tools. Only sources with valid URLs and\n * non-image types are included.\n */\nexport function extractSourcesFromParts(\n  parts: ToolInvocationUIPart[] | undefined\n): ExtractSourceRecordProps {\n  return (\n    parts?.reduce((accParts, curPart): ExtractSourceRecordProps => {\n      const { toolName, args } = curPart?.toolInvocation ?? {}\n      const sourceName =\n        TOOLS_SOURCES_TITLES[toolName as keyof typeof TOOLS_SOURCES_TITLES] ??\n        \"\"\n      const sources =\n        args?.data?.sources?.filter(\n          ({ type, url }: Source) => type !== \"image\" && !!url?.length\n        ) ?? []\n\n      if (!sources?.length) return accParts\n\n      return {\n        ...accParts,\n        ...(sourceName in accParts\n          ? { [sourceName]: [...accParts[sourceName], ...sources] }\n          : { [sourceName]: sources }),\n      }\n    }, {} as ExtractSourceRecordProps) ?? {}\n  )\n}\n\n/**\n * Parses the stringified JSON properties of an object, leaving non-JSON string properties unchanged.\n *\n * @param {Record<string, unknown>} obj - The object containing properties to parse.\n * @return {Record<string, unknown>} A new object with parsed JSON properties where applicable.\n */\nfunction jsonParseProperties(\n  obj: Record<string, unknown>\n): Record<string, unknown> {\n  const parsedObj: Record<string, unknown> = {}\n\n  for (const key in obj) {\n    const value = obj[key]\n\n    try {\n      parsedObj[key] = JSON.parse(value as string)\n    } catch {\n      parsedObj[key] = value\n    }\n  }\n\n  return parsedObj\n}\n\n/**\n * Creates a part object that represents a tool invocation with specified properties.\n *\n * @param {string} toolName - The name of the tool to be invoked.\n * @param {object} props - The properties or arguments to be included in the tool invocation.\n * @return {object} Returns an object representing the tool invocation, including the tool call ID, tool name, and arguments.\n */\nfunction createPart(toolName: string, props: object): object {\n  return {\n    type: \"tool-invocation\",\n    toolInvocation: {\n      toolCallId: uniqueId(),\n      toolName,\n      args: {\n        ...props,\n      },\n    },\n  }\n}\n\n/**\n * Processes an array of content models to create assistant message parts that match specified tools.\n *\n * @param {ContentModelRead[]} content - An array of content models to filter and transform into message parts.\n * @return {object[]} - An array of objects representing the assistant message parts.\n */\nfunction createAssistantMessageParts(content: ContentModelRead[]): object[] {\n  return content\n    .filter((cnt: ContentModelRead) => ALLOWED_TOOLS.includes(cnt.tool))\n    .map((cnt: ContentModelRead) => {\n      const { tool: toolName, value } = cnt\n\n      return createPart(\n        toolName,\n        jsonParseProperties(value as Record<string, unknown>)\n      )\n    })\n}\n\n/**\n * Converts a list of user chat message models from a database format to a format suitable for AI processing.\n *\n * @param {ListUserChatMessagesModelResponseV2[]} messages - The list of messages to be converted. Each message contains properties such as role, content, and timestamp.\n * @return {unknown} The processed list of messages sorted by timestamp, where user and assistant messages are converted into respective formats.\n */\nexport function dbMessagesToAIMessages(\n  messages: ListUserChatMessagesModelResponseV2[]\n): unknown {\n  return (messages || [])\n    .sort((a, b) => a.timestamp - b.timestamp)\n    .map((message) => {\n      const { role, content } = message\n\n      if (role === \"user\") {\n        const userMessageContent = Array.isArray(message.content)\n          ? message.content\n              .filter((cnt: ContentModelRead) => cnt.tool === \"none\")\n              .map((cnt) => cnt.value)\n              .join(\"\")\n          : message.content\n\n        return {\n          ...message,\n          content: userMessageContent,\n        }\n      }\n      if (role === \"assistant\") {\n        return {\n          ...message,\n          annotations: [\n            {\n              id: message.id,\n              references: message.references,\n            },\n          ],\n          parts: createAssistantMessageParts(content as ContentModelRead[]),\n        }\n      }\n    })\n}\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/utils/index.ts"
    },
    {
      "path": "registry/new-york/stream/blocks/chat/utils/referencesBuilder.ts",
      "content": "type ReferenceType =\n  | \"brandkit\"\n  | \"document\"\n  | \"chat\"\n  | \"chatMessage\"\n  | \"component\"\n\ntype ApiVersion = \"v1\" | \"v2\"\n\ntype Reference = {\n  type: ReferenceType\n  id: string\n  path: string\n  isArtefact?: boolean\n}\n\nexport type PathOptions = Pick<Reference, \"id\"> & {\n  apiVersion?: ApiVersion\n  isArtefact?: boolean\n}\n\nexport function ReferencesBuilder({\n  orgId,\n  userId,\n}: {\n  orgId: string\n  userId: string\n}) {\n  const references: Reference[] = []\n\n  return {\n    addBrandkit: function ({ id, apiVersion = \"v1\", isArtefact }: PathOptions) {\n      references.push({\n        type: \"brandkit\",\n        id,\n        path: `/api/brands/${apiVersion}/organizations/${orgId}/brandkits/${id}/references`,\n        ...(() => {\n          return (\n            isArtefact !== undefined && {\n              isArtefact,\n            }\n          )\n        })(),\n      })\n      return this\n    },\n    addDocument: function ({ id, apiVersion = \"v1\", isArtefact }: PathOptions) {\n      references.push({\n        type: \"document\",\n        id,\n        path: `/api/documents/${apiVersion}/organizations/${orgId}/documents/${id}/references`,\n        ...(() => {\n          return (\n            isArtefact !== undefined && {\n              isArtefact,\n            }\n          )\n        })(),\n      })\n      return this\n    },\n    addChat: function ({\n      id,\n      apiVersion = \"v1\",\n      brandkitId = \"\",\n      isArtefact,\n    }: PathOptions & { brandkitId?: string }) {\n      references.push({\n        type: \"chat\",\n        id,\n        path: `/api/chats/${apiVersion}/organizations/${orgId}/users/${userId}/chats/${id}/references${brandkitId && `/${brandkitId}`}`,\n        ...(() => {\n          return (\n            isArtefact !== undefined && {\n              isArtefact,\n            }\n          )\n        })(),\n      })\n      return this\n    },\n    addChatMessage: function ({\n      id,\n      messageId,\n      apiVersion = \"v1\",\n      isArtefact,\n    }: PathOptions & { messageId: string }) {\n      references.push({\n        type: \"chatMessage\",\n        id: messageId,\n        path: `/api/chats/${apiVersion}/organizations/${orgId}/users/${userId}/chats/${id}/messages/${messageId}/references`,\n        ...(() => {\n          return (\n            isArtefact !== undefined && {\n              isArtefact,\n            }\n          )\n        })(),\n      })\n      return this\n    },\n    build: function () {\n      return references\n    },\n  }\n}\n\nexport default ReferencesBuilder\n",
      "type": "registry:component",
      "target": "components/stream-components/blocks/chat/utils/referencesBuilder.ts"
    },
    {
      "path": "registry/new-york/stream/stream.css",
      "content": "/* Stream only related classes */\n.stream-chat-container {\n    width: 100%;\n    max-width: 800px;\n    margin-left: auto;\n    margin-right: auto;\n}\n\n.stream-chat-editable[contenteditable] {\n    outline: 0 solid transparent !important;\n}\n\n.stream-w-icon {\n    width: 1.571428571428571em;\n}\n\n.stream-w-icon-2xl {\n    width: 3rem;\n}\n\n.stream-w-icon-2xs {\n    width: 1.25rem;\n}\n\n.stream-w-icon-3xl {\n    width: 3.5rem;\n}\n\n.stream-w-icon-3xs {\n    width: 1rem;\n}\n\n.stream-w-icon-4xl {\n    width: 4rem;\n}\n\n.stream-w-icon-5xl {\n    width: 5rem;\n}\n\n.stream-w-icon-6xl {\n    width: 6rem;\n}\n\n.stream-w-icon-7xl {\n    width: 7rem;\n}\n\n.stream-w-icon-8xl {\n    width: 8rem;\n}\n\n.stream-w-icon-lg {\n    width: 2.25rem;\n}\n\n.stream-w-icon-md {\n    width: 2rem;\n}\n\n.stream-w-icon-sm {\n    width: 1.75rem;\n}\n\n.stream-w-icon-xl {\n    width: 2.5rem;\n}\n\n.stream-w-icon-xs {\n    width: 1.5rem;\n}\n\n.stream-icon {\n    height: 1.571428571428571em;\n}\n\n.stream-icon-2xl {\n    height: 3rem;\n}\n\n.stream-icon-2xs {\n    height: 1.25rem;\n}\n\n.stream-icon-3xl {\n    height: 3.5rem;\n}\n\n.stream-icon-3xs {\n    height: 1rem;\n}\n\n.stream-icon-4xl {\n    height: 4rem;\n}\n\n.stream-icon-5xl {\n    height: 5rem;\n}\n\n.stream-icon-6xl {\n    height: 6rem;\n}\n\n.stream-icon-7xl {\n    height: 7rem;\n}\n\n.stream-icon-lg {\n    height: 2.25rem;\n}\n\n.stream-icon-md {\n    height: 2rem;\n}\n\n.stream-icon-sm {\n    height: 1.75rem;\n}\n\n.stream-icon-xl {\n    height: 2.5rem;\n}\n\n.stream-icon-xs {\n    height: 1.5rem;\n}\n\n.stream-bg-ai-400 {\n    background-image: var(--ai-400);\n    background-color: var(--ai-400);\n}\n\n.ai-textbox-expanded-border-radius {\n    border-radius: calc(1rem - 1px);\n}",
      "type": "registry:component",
      "target": "components/stream-components/stream.css"
    }
  ],
  "categories": [
    "stream",
    "ui",
    "chat",
    "messages"
  ]
}